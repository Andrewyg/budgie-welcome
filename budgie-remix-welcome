#! /usr/bin/python3
# -*- coding:utf-8 -*-
#
# Copyright 2012-2013 "Korora Project" <dev@kororaproject.org>
# Copyright 2013 "Manjaro Linux" <support@manjaro.org>
# Copyright 2014 Antergos
# Copyright 2016 Ubuntu Mate
# Copyright 2016 budgie-remix
#
# budgie-remix welcome is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# budgie-remix welcome is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with budgie-remix welcome. If not, see <http://www.gnu.org/licenses/>.
#

""" Welcome App for budgie-remix """

import gi

gi.require_version('WebKit2', '4.0')

import inspect
import os
# import json
import signal
import subprocess
import sys
import urllib.request
import urllib.error
import webbrowser
import socket
import platform

from gi.repository import WebKit2, Gtk
from threading import Thread
from Queue import Queue

import apt

class AppView(WebKit2.WebView):

    def __init__(self):
        WebKit2.WebView.__init__(self)

        self.connect('load-changed', self._load_changed_cb)
        self.connect('notify::title', self._title_changed_cb)
        self.connect('context-menu', self._context_menu_cb)
        
        self.l_uri = None

    def _push_config(self):
        # TODO: push notification should be connected to angularjs and use a
        # broadcast event any suitable controllers will be able to listen and
        # respond accordingly, for now we just use jQuery to manually toggle
            
        self.run_javascript("$('span[name=\"distro-name\"]').html('{}')".format(systemstate.distroname))

        if systemstate.session_type == 'live':
            app.update_page('.live-session-only', 'show') 
        else:
            app.update_page('.normal-session-only', 'show')

        
        if systemstate.is_online:
            self.run_javascript("$('.offline').hide()")
        else:
            self.run_javascript("$('.offline').show()")
            
        current_page = app.current_page

        ### Getting Started Page ###
        if current_page == 'gettingstarted.html':
            # Display information tailored to graphics vendor (Getting Started / Drivers)
            self.run_javascript('var graphicsVendor = "' + systemstate.graphics_vendor + '";')
            self.run_javascript('var graphicsGrep = "' + systemstate.graphics_grep + '";')
            app.update_page('#boot-mode', 'html', systemstate.boot_mode)
            graphics_vendor = systemstate.graphics_vendor
            
            if graphics_vendor == 'NVIDIA':
                app.update_page('.graphics-nvidia', 'fadeIn')
            elif graphics_vendor == 'AMD':
                app.update_page('.graphics-amd', 'fadeIn')
            elif graphics_vendor == 'Intel':
                app.update_page('.graphics-intel', 'fadeIn')
            elif graphics_vendor == 'VirtualBox':
                app.update_page('.graphics-vbox', 'fadeIn')
            else:
                app.update_page('.graphics-unknown', 'fadeIn')
              
            
        ### Index Page ###
        elif current_page == 'index.html':
            if systemstate.autostart:
                app.update_page('#autostart', 'html', '&#xE837;')
            else:
                app.update_page('#autostart', 'html', '&#xE836;')
                
        ### All pages with install/removal ###
        if current_page in ['gettingstarted.html', 'recommendations.html']:
            app.update_page('[id$=install]', 'hide')
            app.update_page('[id$=remove]', 'hide')
            
            def checkInstallationStatus():
                
                for code in PackageDict.getShortCodes(current_page[:-5]):
                    package = PackageDict.getPackageName(code)
                    
                    if pm.hasInstalled(package):
                        app.update_page('#' + code + '-remove', 'fadeIn')
                    else:
                        app.update_page('#' + code + '-install', 'fadeIn')
            
            # Checking on cache will take sometime. So run it on a
            # separate thread.    
            thread = Thread(target = checkInstallationStatus)
            thread.start()
                
        # Apply intermediate actions, if any are present
        if current_page in systemstate.intermediate_actions:
            for action in systemstate.intermediate_actions[app.current_page]:
                app.update_page(action[0], action[1], action[2], action[3])


    def _load_changed_cb(self, view, frame):
        uri = str(self.get_uri())
        app.current_page = uri.rsplit('/', 1)[1]
        self._push_config()

    def _title_changed_cb(self, view, frame):
        title = self.get_title()
        
        # An empty command get executed while toggling startup
        # option. Actual reason for this command execution needs
        # to be investigated.
        if title == '':
            return
        
        self._do_command(title)
        
    def _context_menu_cb(self, webview, menu, event, htr, user_data=None):
        # Disable context menu.
        return True

    def _do_command(self, uri):
        
        if uri == 'control':
            subprocess.Popen(['gnome-control-center'])
        elif uri == 'update':
            subprocess.Popen(['update-manager'])
        elif uri == 'drivers':
            subprocess.Popen(['software-properties-gtk', '--open-tab=4'])
        elif uri == 'language':
            subprocess.Popen(['gnome-control-center', 'region'])
        elif uri == 'users':
            subprocess.Popen(['gnome-control-center', 'user-accounts'])
        elif uri == 'backup':
            subprocess.Popen(['deja-dup-preferences'])
        elif uri == 'firewall':
            subprocess.Popen(['gufw'])
        elif uri.startswith('install?'):
            code = uri[8:]
            
            package = PackageDict.getPackageName(code)
            
            script = False
            
            if code in ["restricted-extras", "flatpak", "steam"]:
                script = True
            
            self.installPackage(code, package, script)
           
        elif uri.startswith('remove?'):
            code = uri[7:]
            
            package = PackageDict.getPackageName(code)
                
            self.removePackage(code, package)
        # elif uri == 'install':
            # subprocess.Popen(['sudo','live-installer'])
        # elif uri == 'install-cli':
            # subprocess.Popen(['xdg-terminal','sudo setup'])
        elif uri == 'software-center':
            try:
                subprocess.Popen(['gnome-software'])
            except Exception as e:
                message = "Seems that GNOME Software is not installed. If this problem persists " +\
                           "even after installing GNOME Software, please contact us with following " +\
                           "error message"
                popup = PopupMessage(message, PopupMessage.ERROR, e)
                
                popup.showMessage()
                
        elif uri == 'close':
            Gtk.main_quit()
        elif uri == 'toggle-startup':
            # toggle autostart
            systemstate.autostart_toggle()
            self._push_config()
            self.l_uri = None
            # WebKit2.WebView.reload(self)
            
        elif uri == "checkInternetConnection":
            systemstate.check_internet_connection()
            self._push_config()
        elif uri.startswith("link?"):
            webbrowser.open_new_tab(uri[5:])
        elif uri == 'init-system-info':
            systemstate.get_system_info(self)
        else:
            print('Unknown command: %s' % uri)
            
            
            
    def installPackage(self, code, package, script):
        def threadedMethod():
            actions = [
                ['#' + code + '-install', 'addClass', 'disabled', None],
                ['#' + code + '-status', 'fadeIn', None, None]
            ]
            
            for action in actions:
                app.update_page(action[0], action[1], action[2], action[3])
            
            systemstate.addIntermediateActions(app.current_page, actions)
            
            pmentry = PMEntry(PMEntry.INSTALL, code, actions, app.current_page, script))
            
            pm_queue.put(pmentry)
            
        Thread(target = threadedMethod).start()
        
    def removePackage(self, code, package):
        def threadedMethod():
            actions = [
                ['#' + code + '-remove', 'addClass', 'disabled', None],
                ['#' + code + '-status', 'fadeIn', None, None]
            ]
            
            for action in actions:
                app.update_page(action[0], action[1], action[2], action[3])
            
            systemstate.addIntermediateActions(app.current_page, actions)
            
            pmentry = PMEntry(PMEntry.REMOVE, code, actions, app.current_page))
            
            pm_queue.put(pmentry)
            
        Thread(target = threadedMethod).start()
      
   
class Debug(object):
    def __init__(self):
        self.verbose_level = 0

    def stdout(self, item, info, verbosity=0, colour=0):
        # Only colourise output if running in a real terminal.
        if sys.stdout.isatty():
            end = '\033[0m'
            if colour == 1:            # Failure (Red)
                start = '\033[91m'
            elif colour == 2:          # Success (Green)
                start = '\033[92m'
            elif colour == 3:          # Action (Yellow)
                start = '\033[93m'
            elif colour == 4:          # Debug (Blue)
                start = '\033[96m'
            else:                      # Normal/Misc (White)
                start = '\033[0m'

        # Ignore colours when redirected or piped.
        else:
            start = ''
            end   = ''

        # Output the message depending how detailed it is.
        if self.verbose_level >= verbosity:
            print(start + '[' + item + '] ' + info, end)            

class PopupMessage(object):
    ERROR = 0
    CONFIRMATION = 1
    
    def __init__(self, message, type, trace = None):
        '''
         message => Messge to user
         type => Type of message(error, confirmation ..etc)
         trace => Error trace, if available
        '''
        self.trace = trace
        self.message = message
        self.type = type
        
    def showMessage(self):
        if self.type == PopupMessage.ERROR:
            app.update_page('#popup-message', 'html', self.message)
            app.update_page('#trace', 'val', str(self.trace))
            app.update_page('#popup-message-window', 'fadeIn')
        else:
            dbg.stdout(self.type, 'message is not handled yet', 3)

            
class PackageManager(Thread):
    
    def __init__(self, queue):
        Thread.__init__(self)
        
        # Don't create cache object each time instead use global cache
        self.cache = cache
        self.queue = queue
        
    def hasInstalled(self, package):
        try:
            return self.cache[package].is_installed
        except:
            return False
    
    def run(self):
        while True:
            entry = self.queue.get()
            
            filename = entry.filename
            code = entry.code
            package = PackageDict.getPackageName(code)
            
            if entry.task = PMEntry.INSTALL:
                self.install(entry.package, entry.script)
                app.update_page('#' + code + '-install', 'removeClass', 'disabled')
            elif entry.task == PMEntry.REMOVE:
                self.remove(entry.package)
                app.update_page('#' + code + '-remove', 'removeClass', 'disabled')
            
            app.update_page('#' + code + '-status', 'fadeOut')
            
            for action in entry.actions:
                systemstate.removeIntermediateActions(filename, actions)
            
            app._push_config()
            self.reload_cache()
            
            self.queue.task_done()
    
    # Don't know how to get root privileage for installing and 
    # removing packages using apt module. So using regular command
    # with pkexec. Make it a blocking call and run in thread.    
    def install(self, package, script = False):
        if script:
            process = subprocess.Popen(['pkexec', 'sh', app._data_path + '/scripts/' + package])
        else:
            process = subprocess.Popen(['pkexec', 'apt', 'install', '-y', package])
        retval = process.wait()
        
        self.processOutput(process, retval)

    def remove(self, package):
        process = subprocess.Popen(['pkexec', 'apt', 'remove', '-y', package])
        retval = process.wait()
        
        self.processOutput(process, retval)
        
    def reload_cache(self):
        dbg.stdout('Apt', 'Reloading cache...', 0, 3)
        self.cache.close()
        self.cache = apt.Cache()
        dbg.stdout('Apt', 'Cache reloaded.', 0, 2)
        
    def processOutput(self, process, retval):
    
        output = ''
    
        if process.stdout:
            output += str(process.stdout.read())
        
        if process.stderr:
            output += str(process.stderr.read())
        
        # Colud n't get lock for apt
        if retval == 100:
            message = "Seems that another installation/removal is in progress. If you think this is a mistake" +\
                "please contact us with following error message"
            popup = PopupMessage(message, PopupMessage.ERROR, output)
                
            popup.showMessage()
            
class PackageDict(object):
    '''
    Map some short codes with packages. Install/Remove buttons
    will be represented by short code like #code-remove and 
    #code-install. This will allow to check installation status
    of each package using a loop instead of checking seperately
    '''
    
    pagemap = {
        'recommendations' : ['flatpak', 'steam'],
        'gettingstarted' : ['restricted-extras', 'keyboard-chinese',
        'keyboard-japanese', 'keyboard-korean', 'backup', 'firewall'
        ]
    }
    codemap = {
        'restricted-extras' : 'ubuntu-restricted-extras',
        'keyboard-chinese' : 'ibus-pinyin',
        'keyboard-japanese' : 'ibus-anthy',
        'keyboard-korean' : 'ibus-hangul',
        'backup' : 'deja-dup',
        'firewall' : 'gufw',
        'steam' : 'steam',
        'flatpak' : 'flatpak'
    }
    
    @staticmethod
    def getShortCodes(filename):
        return PackageDict.pagemap[filename]
    
    @staticmethod
    def getPackageName(code):
        try:
            return PackageDict.codemap[code]
        except KeyError:
            return None
            
class PMEntry(object):
    INSTALL = 0
    REMOVE = 1
    
    def __init__(self, task, code, actions, filename, script = False):
        self.task = task
        self.code = code
        
        # UI updates done and remembered before starting task
        # and need to 'forget' after finishing task
        self.actions = actions
        # File in which installation/removal option is listed.
        # This is required to remove actions after installation
        # /removal
        self.filename = filename
        self.script = script

class SystemState(object):
    def __init__(self):
        # Set default variables
        self.is_online = False
        self.updates_subscribed = False
        self.welcome_version = 'Unknown'

        # Full path to binary
        self._welcome_bin_path = os.path.abspath(inspect.getfile(inspect.currentframe()))

        # User's autostart directory and full path to autostart symlink.
        # Used for systemstate.autostart_toggle() function.
        self._autostart_dir = os.path.expanduser('~/.config/autostart/')
        self._autostart_path = os.path.expanduser(os.path.join(self._autostart_dir, 'budgie-welcome.desktop'))
        self.autostart = self.autostart_check()

        # Get current architecture of system.
        # Outputs 'i386', 'amd64', etc - Based on packages instead of kernel (eg. i686, x86_64).
        self.arch = str(subprocess.Popen(['dpkg','--print-architecture'], stdout=subprocess.PIPE).communicate()[0]).strip('\\nb\'')

        # Collect distribution info
        self.gatherDistroInfo()

        # Determine which type of session we are in.
        if arg.simulate_session:
            self.session_type = arg.simulate_session
        elif subprocess.call("df | grep -w / | grep -q '/cow'", shell=True) == 0:
            self.session_type = 'live'
        else:
            self.session_type = 'normal'

        # To inform the user if they are running in BIOS or UEFI mode.
        if os.path.exists("/sys/firmware/efi"):
            self.boot_mode = 'UEFI'
        else:
            self.boot_mode = 'BIOS'

        # Multithread to prevent holding up program execution.
        thread1 = Thread(target=self.check_internet_connection)
        thread2 = Thread(target=self.detect_graphics)
        thread1.start()
        thread2.start()
        
        
        # Retain some show/hide actions applied while changing page.
        # This is specially required when page change happens while
        # installation/removal is in progress.
        self.intermediate_actions = {}

    def addIntermediateAction(self, filename, actions):

        if filename not in self.intermediate_actions:
            self.intermediate_actions[filename] = []
            
        self.intermediate_actions[filename] += actions
        
    def removeIntermediateActions(self, filename, actions):
    
        for action in actions:
            self.intermediate_actions[filename].remove(action)
        
        if len(self.intermediate_actions[filename]) == 0:
            del self.intermediate_actions[filename]
            

    def gatherDistroInfo(self):
        # Hard code distributin name, as running external commands would take
        # more time and it will give content mismatch if run in a different OS.
        # self.distroname = self.run_external_command(['lsb_release','-i','-s'])
        self.distroname = 'budgie-remix'
        
        self.os_version = platform.dist()[1]    # → 14.04, 15.10, 16.04
        self.codename = platform.dist()[2]      # → trusty, wily, xenial

    def autostart_check(self):
        # Ensure our autostart directories exist
        if not os.path.exists(self._autostart_dir):
            try:
                os.makedirs(self._autostart_dir)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while checking autostart directory: ' + str(err), 0, 1)
                pass

        # Set boolean if the autostart file exists.
        if os.path.exists(self._autostart_path):
            return True
        else:
            return False

    def autostart_toggle(self):
        if not os.path.exists(self._autostart_path):
            # create the autostart symlink
            try:
                os.symlink('/usr/share/applications/budgie-welcome.desktop', self._autostart_path)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while enabling autostart: ' + str(err), 0, 1)
                pass

        elif os.path.exists(self._autostart_path):
            # remove the autostart symlink
            try:
                os.unlink(self._autostart_path)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while disabling autostart: ' + str(err), 0, 1)
                pass

        self.autostart = self.autostart_check()
        dbg.stdout('Welcome', 'Auto start toggled to: ' + str(self.autostart), 1, 2)

    def check_internet_connection(self):
        url = "http://archive.ubuntu.com/"
        dbg.stdout('Network Test', 'Establishing a connection test to "' + url + '"', 1, 3)

        if arg.simulate_no_connection:
            dbg.stdout('Network Test', 'Simulation flag: Forcing no connection presence. Retrying will reset this.', 0, 1)
            arg.simulate_no_connection = False
            self.is_online = False
            return

        if arg.simulate_force_connection:
            dbg.stdout('Network Test', 'Simulation flag: Forcing a connection presence.', 0, 2)
            dbg.stdout('Network Test', 'WARNING: Do not attempt to install/remove software offline as this may cause problems!', 0, 1)
            arg.simulate_connection = False
            self.is_online = True
            return

        try:
            response = urllib.request.urlopen(url, timeout=2).read().decode('utf-8')
        except socket.timeout:
            dbg.stdout('Network Test', 'Failed. Socket timed out to URL: ' + url, 0, 1)
            self.is_online = False
        except:
            dbg.stdout('Welcome', "Couldn't establish a connection: " + url, 0, 1)
            self.is_online = False
        else:
            dbg.stdout('Welcome', 'Successfully pinged: ' + url, 1, 2)
            self.is_online = True

    def detect_graphics(self):
        # TODO: Support dual graphic cards.
        dbg.stdout('Specs', 'Detecting graphics vendor... ', 1, 3)
        try:
            output = subprocess.Popen('lspci | grep VGA', stdout=subprocess.PIPE, shell='True').communicate()[0]
            output = output.decode(encoding='UTF-8')
        except:
            # When 'lspci' does not find a VGA controller (this is the case for the RPi 2)
            dbg.stdout('Specs', "Couldn't detect a VGA Controller on this system.", 0, 1)
            output = 'Unknown'

        # Scan for and set known brand name.
        if output.find('NVIDIA') != -1:
            self.graphics_vendor = 'NVIDIA'
        elif output.find('AMD') != -1:
            self.graphics_vendor = 'AMD'
        elif output.find('Intel') != -1:
            self.graphics_vendor = 'Intel'
        elif output.find('VirtualBox') != -1:
            self.graphics_vendor = 'VirtualBox'
        else:
            self.graphics_vendor = 'Unknown'

        self.graphics_grep = repr(output)
        self.graphics_grep = self.graphics_grep.split("controller: ",1)[1]
        self.graphics_grep = self.graphics_grep.split("\\n",1)[0]
        dbg.stdout('Specs', 'Detected: ' + str(self.graphics_grep), 1, 2)

    # Collect basic system information
    def run_external_command(self, command, with_shell=False):
        if with_shell:
            raw = str(subprocess.Popen(command, stdout=subprocess.PIPE, shell=True).communicate()[0])
        else:
            raw = str(subprocess.Popen(command, stdout=subprocess.PIPE).communicate()[0])
        output = raw.replace("b'","").replace('b"',"").replace("\\n'","").replace("\\n","")
        return output

    def get_system_info(self, webkit):
        dbg.stdout('Specs', 'Gathering system specifications...', 0, 3)

        # Append a failure symbol beforehand in event something goes horribly wrong.
        stat_error_msg = "Could not gather data."
        html_tag = '<a data-toggle=\'tooltip\' data-placement=\'top\' title=\'' + stat_error_msg + '\'><span class=\'fa fa-warning specs-error\'></span></a>'
        for element in ['distro', 'kernel', 'motherboard', 'boot-mode', 'cpu-model', 'cpu-speed', 'arch-use',
                        'arch-supported', 'memory', 'graphics', 'filesystem', 'capacity', 'allocated-space', 'free-space']:
            app.update_page('#spec'+element, 'html', html_tag)

        ## Distro
        try:
            dbg.stdout('Specs', 'Gathering Data: Distribution', 1, 0)
            distro_description = self.run_external_command(['lsb_release','-d','-s'])
            distro_codename = self.run_external_command(['lsb_release','-c','-s'])
            app.update_page('#spec-distro', 'html', distro_description)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Distribution', 0, 1)

        ## Kernel
        try:
            dbg.stdout('Specs', 'Gathering Data: Kernel', 1, 0)
            kernel = self.run_external_command(['uname','-r'])
            app.update_page('#spec-kernel', 'html', kernel)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Kernel', 0, 1)

        ## Motherboard
        try:
            dbg.stdout('Specs', 'Gathering Data: Motherboard', 1, 0)
            motherboard_name = self.run_external_command(['cat','/sys/devices/virtual/dmi/id/board_name'])
            app.update_page('#spec-motherboard', 'html', motherboard_name)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Motherboard', 0, 1)

        ## CPU Details
        dbg.stdout('Specs', 'Gathering Data: CPU', 1, 0)
        try:
            cpu_model = self.run_external_command(['lscpu | grep "name"'], True).split(': ')[1]
            app.update_page('#spec-cpu-model', 'html', cpu_model)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Model', 0, 1)

        try:
            try:
                # Try obtaining the maximum speed first.
                cpu_speed = int(self.run_external_command(['lscpu | grep "max"'], True).split(': ')[1].strip(' ').split('.')[0])
            except:
                # Otherwise, fetch the CPU's MHz.
                cpu_speed = int(self.run_external_command(['lscpu | grep "CPU MHz"'], True).split(': ')[1].strip(' ').split('.')[0])

            app.update_page('#spec-cpu-speed', 'html', str(cpu_speed) + ' MHz')
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Speed', 0, 1)

        try:
            if self.arch == 'i386':
                cpu_arch_used = '32-bit'
            elif self.arch == 'amd64':
                cpu_arch_used = '64-bit'
            else:
                cpu_arch_used = self.arch
            app.update_page('#spec-arch-use', 'html', cpu_arch_used)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Architecture', 0, 1)

        try:
            cpu_arch_supported = self.run_external_command(['lscpu | grep "mode"'], True).split(': ')[1]
            app.update_page('#spec-arch-supported', 'html', cpu_arch_supported)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Supported Architectures', 0, 1)

        # Adding simple strings. Later this should be converted to translation
        # supported strings after referring welcome app
        gb_prefix = "GB"
        gib_prefix = "GiB"
        mb_prefix = "MB"
        mib_prefix = "MiB"

        ## Root partition (where Distribution is installed) and the rest of that disk.
        try:
            if self.session_type == 'live':
                app.update_page('.spec-hide-live-session', 'hide')
            else:
                dbg.stdout('Specs', 'Gathering Data: Storage', 1, 0)
                ## Gather entire disk data
                root_partition = self.run_external_command(['mount | grep "on / "'], True).split(' ')[0]
                if root_partition[:-2] == "/dev/sd":            # /dev/sdXY
                    root_dev = root_partition[:-1]
                if root_partition[:-2] == "/dev/hd":            # /dev/hdXY
                    root_dev = root_partition[:-1]
                if root_partition[:-3] == "/dev/mmcblk":        # /dev/mmcblkXpY
                    root_dev = root_partition[:-2]
                else:
                    root_dev = root_partition[:-1]              # Generic
                disk_dev_name = root_dev.split('/')[2]
                dbg.stdout('Specs', 'Distribution is installed on disk: ' + root_dev, 1, 4)
                rootfs = os.statvfs('/')
                root_size = rootfs.f_blocks * rootfs.f_frsize
                root_free = rootfs.f_bavail * rootfs.f_frsize
                root_used = root_size - root_free
                entire_disk = self.run_external_command(['lsblk -b | grep "' + disk_dev_name + '" | grep "disk"'], True)
                entire_disk = int(entire_disk.split()[3])

                ## Perform calculations across units
                capacity_GB =   round(entire_disk/1000/1000/1000,1)
                capacity_GiB =  round(entire_disk/1024/1024/1024,1)
                allocated_GB =  round(root_size/1000/1000/1000,1)
                allocated_GiB = round(root_size/1024/1024/1024,1)
                used_GB =       round(root_used/1000/1000/1000,1)
                used_GiB =      round(root_used/1024/1024/1024,1)
                free_GB =       round(root_free/1000/1000/1000,1)
                free_GiB =      round(root_free/1024/1024/1024,1)
                other_GB =      round((entire_disk-root_size)/1000/1000/1000,1)
                other_GiB =     round((entire_disk-root_size)/1024/1024/1024,1)

                # Show megabytes/mebibytes (in red) if gigabytes are too small.
                if capacity_GB <= 1:
                    capacity_GB = str(round(entire_disk/1000/1000,1)) + ' ' + mb_prefix
                    capacity_GiB = str(round(entire_disk/1024/1024,1)) + ' ' + mib_prefix
                else:
                    capacity_GB = str(capacity_GB) + ' ' + gb_prefix
                    capacity_GiB = str(capacity_GiB) + ' ' + gib_prefix

                if allocated_GB <= 1:
                    allocated_GB =  str(round(root_size/1000/1000,1)) + ' ' + mb_prefix
                    allocated_GiB = str(round(root_size/1024/1024,1)) + ' ' + mib_prefix
                else:
                    allocated_GB = str(allocated_GB) + ' ' + gb_prefix
                    allocated_GiB = str(allocated_GiB) + ' ' + gib_prefix

                if used_GB <= 1:
                    used_GB =  str(round(root_used/1000/1000,1)) + ' ' + mb_prefix
                    used_GiB = str(round(root_used/1024/1024,1)) + ' ' + mib_prefix
                else:
                    used_GB = str(used_GB) + ' ' + gb_prefix
                    used_GiB = str(used_GiB) + ' ' + gib_prefix

                if free_GB <= 1:
                    free_GB =  str(round(root_free/1000/1000,1)) + ' ' + mb_prefix
                    free_GiB = str(round(root_free/1024/1024,1)) + ' ' + mib_prefix
                    app.update_page('#spec-free-space', 'addClass', 'specs-error')
                else:
                    free_GB = str(free_GB) + ' ' + gb_prefix
                    free_GiB = str(free_GiB) + ' ' + gib_prefix

                if other_GB <= 1:
                    other_GB =  str(round((entire_disk-root_size)/1000/1000,1)) + ' ' + mb_prefix
                    other_GiB = str(round((entire_disk-root_size)/1024/1024,1)) + ' ' + mib_prefix
                else:
                    other_GB = str(other_GB) + ' ' + gb_prefix
                    other_GiB = str(other_GiB) + ' ' + gib_prefix

                ## Append data to HTML.
                app.update_page('#spec-filesystem', 'html', root_partition)
                app.update_page('#spec-capacity', 'html', capacity_GB + ' <span class=\'secondary-value\'>(' + capacity_GiB + ')</span>')
                app.update_page('#spec-allocated-space', 'html',  allocated_GB + ' <span class=\'secondary-value\'>(' + allocated_GiB + ')</span>')
                app.update_page('#spec-used-space', 'html', used_GB + ' <span class=\'secondary-value\'>(' + used_GiB + ')</span>')
                app.update_page('#spec-free-space', 'html', free_GB + ' <span class=\'secondary-value\'>(' + free_GiB + ')</span>')
                app.update_page('#spec-other-space', 'html', other_GB + ' <span class=\'secondary-value\'>(' + other_GiB + ')</span>')

                ## Calculate representation across physical disk
                disk_percent_UM_used = int(round(root_used / entire_disk * 100)) * 2
                disk_percent_UM_free = int(round(root_free / entire_disk * 100)) * 2
                disk_percent_other   = (200 - disk_percent_UM_used - disk_percent_UM_free)
                dbg.stdout('Specs', ' Disk: ' + root_dev, 1, 4)
                dbg.stdout('Specs', '  -- OS Used: ' + str(root_used) + ' bytes (' + str(disk_percent_UM_used/2) + '%)', 1, 4)
                dbg.stdout('Specs', '  -- OS Free: ' + str(root_free) + ' bytes (' + str(disk_percent_UM_free/2) + '%)', 1, 4)
                dbg.stdout('Specs', '  -- Other Partitions: ' + str(entire_disk - root_size) + ' bytes (' + str(disk_percent_other/2) + '%)', 1, 4)

                app.update_page('#disk-used', 'width', str(disk_percent_UM_used) + 'px')
                app.update_page('#disk-free', 'width', str(disk_percent_UM_free) + 'px')
                app.update_page('#disk-other', 'width', str(disk_percent_other) + 'px')

        except Exception as err:
            print(err)
            dbg.stdout('Specs', 'Failed to gather data: Storage', 0, 1)

        ## RAM
        try:
            dbg.stdout('Specs', 'Gathering Data: RAM (Memory)', 1, 0)
            ram_bytes = self.run_external_command(['free -b | grep "Mem:" '], True)
            ram_bytes = float(ram_bytes.split()[1])
            if round(ram_bytes / 1024 / 1024) < 1024:
                ram_xb = str(round(ram_bytes / 1000 / 1000, 1)) + ' ' + mb_prefix
                ram_xib = str(round(ram_bytes / 1024 / 1024, 1)) + ' ' + mib_prefix
            else:
                ram_xb =  str(round(ram_bytes / 1000 / 1000 / 1000, 1)) + ' ' + gb_prefix
                ram_xib = str(round(ram_bytes / 1024 / 1024 / 1024, 1)) + ' ' + gib_prefix
            ram_string = ram_xb + ' <span class=\'secondary-value\'>(' + ram_xib + ')</span>'
            app.update_page('#spec-memory', 'html', ram_string)
        except:
            dbg.stdout('Specs', 'Failed to gather data: RAM (Memory)', 0, 1)

        ## Graphics
        app.update_page('#spec-graphics', 'html', self.graphics_grep)

        # Check internet connectivity status.
        if self.is_online:
            app.update_page('#specs-has-net', 'show')
            app.update_page('#specs-has-no-net', 'hide')
        else:
            app.update_page('#specs-has-net', 'hide')
            app.update_page('#specs-has-no-net', 'show')


        # Display UEFI/BIOS boot mode.
        if systemstate.arch == 'i386' or systemstate.arch == 'amd64':
            app.update_page('#spec-boot-mode', 'html', self.boot_mode)

        # Hide root storage info if in a live session.
        if self.session_type == 'live':
            app.update_page('.spec-3', 'hide')

        # Data cached, ready to display.
        app.update_page('#specs-loading', 'fadeOut', 'fast')
        app.update_page('#specs-tabs', 'fadeIn', 'fast')
        app.update_page('#specs-basic', 'fadeIn', 'medium')
        app.update_page('#specs-busy-basic', 'fadeOut', 'fast')
        webkit.run_javascript('setCursorNormal()')


class WelcomeApp(object):

    def __init__(self):

        self.current_page = ""

        # establish our location
        self._location = os.path.dirname(
            os.path.abspath(inspect.getfile(inspect.currentframe())))

        # check for relative path
        if(os.path.exists(os.path.join(self._location, 'data/'))):
            print('Using relative path for data source.\
                   Non-production testing.')
            self._data_path = os.path.join(self._location, 'data/')
        elif(os.path.exists('/usr/share/budgie-remix-welcome/')):
            print('Using /usr/share/budgie-remix-welcome/ path.')
            self._data_path = '/usr/share/budgie-remix-welcome/'
        else:
            print('Unable to source the budgie-remix-welcome data directory.')
            sys.exit(1)

        self._build_app()

    def _build_app(self):
        # build window
        w = Gtk.Window()
        w.set_position(Gtk.WindowPosition.CENTER)
        w.set_wmclass('budgie-remix welcome', 'budgie-remix welcome')
        w.set_title('')
        w.set_size_request(992, 520)
        w.set_decorated(False)

        icon_dir = os.path.join(self._data_path, 'img', 'distro-icon.svg')
        w.set_icon_from_file(icon_dir)

        # build webkit container
        mv = AppView()

        # load our index file
        file = os.path.abspath(os.path.join(self._data_path, 'index.html'))
        uri = 'file://' + urllib.request.pathname2url(file)
        mv.load_uri(uri)

        # build scrolled window widget and add our appview container
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        sw.add(mv)

        # build a an autoexpanding box and add our scrolled window
        b = Gtk.VBox(homogeneous=False, spacing=0)
        b.pack_start(sw, expand=True, fill=True, padding=0)

        # add the box to the parent window and show
        w.add(b)
        w.connect('delete-event', self.close)
        w.show_all()

        self._window = w
        self.webkit = mv

    def run(self):
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        Gtk.main()

    def close(self, p1, p2):
        Gtk.main_quit(p1, p2)
        
    def update_page(self, element, function, parm1=None, parm2=None):
        """ Runs a JavaScript jQuery function on the page,
            ensuring correctly parsed quotes. """
        if parm1 and parm2:
            self.webkit.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "', '" + parm2.replace("'", '\\\'') + "')")
        if parm1:
            self.webkit.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "')")
        else:
            self.webkit.run_javascript('$("' + element + '").' + function + '()')
            
    def run_javascript(self, script):
        print("Running script", script)
        self.webkit.run_javascript(script)

class Arguments(object):
    '''Check arguments passed the application.'''

    def __init__(self):
        self.verbose_enabled = False
        self.simulate_arch = None
        self.simulate_session = None
        self.simulate_codename = None
        self.simulate_no_connection = False
        self.simulate_force_connection = False
        self.jump_software_page = False
        self.simulate_software_changes = False
        self.locale = None
        self.jump_to = None

        for arg in sys.argv:
          if arg == '--help' or arg == '-h':
              print('\nWelcome App Parameters\n  Intended for debugging and testing purposes only!\n')
              print('\nUsage: budgie-remix-welcome [arguments]')
              #     | Command                      | Help Text                                     |
              print('  -d, --dev, --debug           Disables locales and is very verbose')
              print('                               intended for development purposes.')
              print('  --font-dpi=NUMBER            Adapt zoom setting based on DPI. Default 96.')
              print('  -h, --help                   Show this help text.')
              print('  --force-arch=ARCH            Simulate a specific architecture.')
              print('                                -- Options: i386, amd64, armhf, powerpc')
              print('  --force-codename=CODENAME    Simulate a specific release.')
              print('                                -- Examples: trusty, wily, xenial')
              print('  --force-net                  Simulate a working internet connection.')
              print('  --force-no-net               Simulate no internet connection.')
              print('  --force-session=TYPE         Simulate a specific architecture.')
              print('                                -- Options: guest, live, pi, vbox')
              print('  --jump-to=PAGE               Open a specific page, excluding *.html')
              print('  --locale=CODE                Locale to use. e.g. fr_FR.')
              print('  -v, --verbose                Show more details to stdout (for diagnosis).')
              print('')
              exit()

          if arg == '--verbose' or arg == '-v':
              dbg.stdout('Debug', 'Verbose mode enabled.', 0, 0)
              dbg.verbose_level = 1

          if arg.startswith('--force-arch'):
              try:
                  self.simulate_arch = arg.split('--force-arch=')[1]
                  if not self.simulate_arch == 'i386' and not self.simulate_arch == 'amd64' and not self.simulate_arch == 'armhf' and not self.simulate_arch == 'powerpc':
                      dbg.stdout('Debug', 'Unrecognised architecture: ' + self.simulate_arch, 0, 1)
                      exit()
                  else:
                      dbg.stdout('Debug', 'Simulating architecture: ' + self.simulate_arch, 0, 0)
              except:
                  dbg.stdout('Debug', 'Invalid arguments for "--force-arch"', 0, 1)
                  exit()

          if arg.startswith('--force-session'):
              try:
                  self.simulate_session = arg.split('--force-session=')[1]
                  if not self.simulate_session == 'normal' and not self.simulate_session == 'live':
                      dbg.stdout('Debug', 'Unrecognised session type: ' + self.simulate_session, 0, 1)
                      exit()
                  else:
                      dbg.stdout('Debug', 'Simulating session: ' + self.simulate_session, 0, 0)
              except:
                  dbg.stdout('Debug', 'Invalid arguments for "--force-session"', 0, 1)
                  exit()

          if arg.startswith('--force-codename'):
              self.simulate_codename = arg.split('--force-codename=')[1]
              dbg.stdout('Debug', 'Simulating Ubuntu release: ' + self.simulate_codename, 0, 0)

          if arg == '--force-no-net':
              dbg.stdout('Debug', 'Simulating the application without an internet connection.', 0, 0)
              self.simulate_no_connection = True

          if arg == '--force-net':
              dbg.stdout('Debug', 'Forcing the application to think we\'re connected with an internet connection.', 0, 0)
              self.simulate_force_connection = True

          if arg == '--dev' or arg == '--debug' or arg == '-d':
              dbg.stdout('Debug', 'Running in debugging mode.', 0, 0)
              dbg.verbose_level = 2
              self.locale = 'null'

          if arg.startswith('--locale='):
              self.locale = arg.split('--locale=')[1]
              dbg.stdout('Debug', 'Setting locale to: ' + self.locale, 0, 0)

          if arg.startswith('--jump-to='):
              self.jump_to = arg.split('--jump-to=')[1]
              dbg.stdout('Debug', 'Opening page: ' + self.jump_to + '.html', 0, 0)


if __name__ == "__main__":

    # Process any parameters passed to the program.
    dbg = Debug()
    arg = Arguments()
    
    cache = apt.Cache()
    pm_queue = Queue()
    pm = PackageManager(pm_queue)
    pm.start()
    
    systemstate = SystemState()
    
    app = WelcomeApp()
    app.run()
