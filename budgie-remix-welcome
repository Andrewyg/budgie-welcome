#! /usr/bin/python3
# -*- coding:utf-8 -*-
#
# Copyright 2012-2013 "Korora Project" <dev@kororaproject.org>
# Copyright 2013 "Manjaro Linux" <support@manjaro.org>
# Copyright 2014 Antergos
# Copyright 2016 Bugie Remix
#
# Budgie Remix Welcome is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Budgie Remix Welcome is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Budgie Remix Welcome. If not, see <http://www.gnu.org/licenses/>.
#

""" Welcome screen for Budgie Remix """

import gi

gi.require_version('WebKit2', '4.0')

import inspect
import os
# import json
import signal
import subprocess
import sys
import urllib.request
import urllib.error
import webbrowser
import socket
import platform

from simplejson import dumps as to_json

from gi.repository import WebKit2, Gtk
from threading import Thread


class WelcomeConfig(object):

    """ Manages Welcome configuration """

    def __init__(self):

        self.is_online = False

        # store our base architecture
        if os.uname()[4] == 'x86_64':
            self._arch = '64-bit'
        else:
            self._arch = '32-bit'

        # store we are a live CD session
        self._live = (os.path.exists('/bootmnt/antergos'))

        # store full path to our binary
        self._welcome_bin_path = os.path.abspath(inspect.getfile(
            inspect.currentframe()))

        # store directory to our welcome configuration
        self._config_dir = os.path.expanduser('~/.config/antergos/welcome/')

        # store full path to our autostart symlink
        self._autostart_path = os.path.expanduser(
            '~/.config/autostart/antergos-welcome.desktop')

        # ensure our config directory exists
        if not os.path.exists(self._config_dir):
            try:
                os.makedirs(self._config_dir)
            except OSError:
                pass
        # does autostart symlink exist
        self._autostart = os.path.exists(self._autostart_path)

        # Hard code distribution name for time being. Later
        # access it using `lsb_release` command.
        self._distroname = 'Budgie Remix'

    @property
    def arch(self):
        return self._arch

    @property
    def autostart(self):
        return self._autostart

    @autostart.setter
    def autostart(self, state):
        if state and not os.path.exists(self._autostart_path):
            # create the autostart symlink
            try:
                os.symlink(
                    '/usr/share/applications/antergos-welcome.desktop',
                    self._autostart_path)
            except OSError:
                pass
        elif not state and os.path.exists(self._autostart_path):
            # remove the autostart symlink
            try:
                os.unlink(self._autostart_path)
            except OSError:
                pass

        # determine autostart state based on absence of the disable file
        self._autostart = os.path.exists(self._autostart_path)

    @property
    def live(self):
        return self._live



class AppView(WebKit2.WebView):

    def __init__(self):
        WebKit2.WebView.__init__(self)

        self._config = WelcomeConfig()

        self.connect('load-changed', self._load_changed_cb)
        self.connect('notify::title', self._title_changed_cb)
        self.connect('context-menu', self._context_menu_cb)
        
        self.l_uri = None

    def _push_config(self):
        # TODO: push notification should be connected to angularjs and use a
        # broadcast event any suitable controllers will be able to listen and
        # respond accordingly, for now we just use jQuery to manually toggle

        self.run_javascript("$('#arch').html('%s')" % self._config.arch)
        self.run_javascript("$('#autostart').toggleClass('icon-check', {})\
            .toggleClass('icon-check-empty', {})".format(to_json
                (self._config._autostart), to_json(not self._config._autostart)))
        self.run_javascript("$('span[name=\"distro-name\"]').html('{}')".format(self._config._distroname))


        if self._config.live:
            self.run_javascript("$('#install').toggleClass('hide', false);")
            self.run_javascript(
                "$('#install-cli').toggleClass('hide', false);")
        else:
            self.run_javascript("$('#build').toggleClass('hide', false);")
            self.run_javascript("$('#donate').toggleClass('hide', false);")

        
        if self._config.is_online:
            self.run_javascript("$('.offline').hide()")
        else:
            self.run_javascript("$('.offline').show()")

        ### Getting Started Page ###
        if app.current_page == 'gettingstarted.html':
            # Display information tailored to graphics vendor (Getting Started / Drivers)
            self.run_javascript('var graphicsVendor = "' + systemstate.graphics_vendor + '";')
            self.run_javascript('var graphicsGrep = "' + systemstate.graphics_grep + '";')
            app.update_page('#boot-mode', 'html', systemstate.boot_mode)


    def _load_changed_cb(self, view, frame):
        uri = str(self.get_uri())
        app.current_page = uri.rsplit('/', 1)[1]
        self._push_config()

    def _title_changed_cb(self, view, frame):
        title = self.get_title()
        self._do_command(title)
        
    def _context_menu_cb(self, webview, menu, event, htr, user_data=None):
        # Disable context menu.
        return True

    def _do_command(self, uri):
      
        if uri == 'gnome-help':
            subprocess.Popen(['yelp'])
        elif uri == 'kde-help':
            subprocess.Popen(['khelpcenter'])
        # elif uri == 'install':
            # subprocess.Popen(['sudo','live-installer'])
        # elif uri == 'install-cli':
            # subprocess.Popen(['xdg-terminal','sudo setup'])
        elif uri == 'close':
            Gtk.main_quit()
        elif uri == 'toggle-startup':
            # toggle autostart
            self._config.autostart ^= True
            self._push_config()
        elif uri == "checkInternetConnection":
            self._config.check_internet_connection()
            self._push_config()
        elif uri.startswith("link?"):
            webbrowser.open_new_tab(uri[5:])
        elif uri == 'init-system-info':
            systemstate.get_system_info(self)
        else:
            print('Unknown command: %s' % uri)
       
class Debug(object):
    def __init__(self):
        self.verbose_level = 0

    def stdout(self, item, info, verbosity=0, colour=0):
        # Only colourise output if running in a real terminal.
        if sys.stdout.isatty():
            end = '\033[0m'
            if colour == 1:            # Failure (Red)
                start = '\033[91m'
            elif colour == 2:          # Success (Green)
                start = '\033[92m'
            elif colour == 3:          # Action (Yellow)
                start = '\033[93m'
            elif colour == 4:          # Debug (Blue)
                start = '\033[96m'
            else:                      # Normal/Misc (White)
                start = '\033[0m'

        # Ignore colours when redirected or piped.
        else:
            start = ''
            end   = ''

        # Output the message depending how detailed it is.
        if self.verbose_level >= verbosity:
            print(start + '[' + item + '] ' + info, end)            

class SystemState(object):
    def __init__(self):
        # Set default variables
        self.is_online = False
        self.updates_subscribed = False
        self.welcome_version = 'Unknown'

        # Full path to binary
        self._welcome_bin_path = os.path.abspath(inspect.getfile(inspect.currentframe()))

        # User's autostart directory and full path to autostart symlink.
        # Used for systemstate.autostart_toggle() function.
        self._autostart_dir = os.path.expanduser('~/.config/autostart/')
        self._autostart_path = os.path.expanduser(os.path.join(self._autostart_dir, 'ubuntu-mate-welcome.desktop'))
        self.autostart = self.autostart_check()

        # Get current architecture of system.
        # Outputs 'i386', 'amd64', etc - Based on packages instead of kernel (eg. i686, x86_64).
        self.arch = str(subprocess.Popen(['dpkg','--print-architecture'], stdout=subprocess.PIPE).communicate()[0]).strip('\\nb\'')

        # Get current version / codename of Distribution in Use in use.
        self.os_version = platform.dist()[1]    # → 14.04, 15.10, 16.04
        self.codename = platform.dist()[2]      # → trusty, wily, xenial

        # Determine which type of session we are in.
        if os.path.exists('/usr/share/glib-2.0/schemas/zubuntu-mate-live.gschema.override'):
            self.session_type = 'live'
        else:
            self.session_type = 'normal'

        # To inform the user if they are running in BIOS or UEFI mode.
        if os.path.exists("/sys/firmware/efi"):
            self.boot_mode = 'UEFI'
        else:
            self.boot_mode = 'BIOS'

        # Multithread to prevent holding up program execution.
        thread1 = Thread(target=self.check_internet_connection)
        thread2 = Thread(target=self.detect_graphics)
        thread1.start()
        thread2.start()

        # Check whether Welcome is subscribed for updates.
        self.welcome_ppa_file = '/etc/apt/sources.list.d/ubuntu-mate-dev-ubuntu-welcome-' + self.codename + '.list'
        if os.path.exists(self.welcome_ppa_file):
            if os.path.getsize(self.welcome_ppa_file) > 0:
                self.updates_subscribed = True

    def reload_cache(self):
        dbg.stdout('Apt', 'Reloading cache...', 0, 3)
        self.apt_cache.close()
        self.apt_cache = apt.Cache()
        dbg.stdout('Apt', 'Cache reloaded.', 0, 2)

    def autostart_check(self):
        # Ensure our autostart directories exist
        if not os.path.exists(self._autostart_dir):
            try:
                os.makedirs(self._autostart_dir)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while checking autostart directory: ' + str(err), 0, 1)
                pass

        # Set boolean if the autostart file exists.
        if os.path.exists(self._autostart_path):
            return True
        else:
            return False

    def autostart_toggle(self):
        if not os.path.exists(self._autostart_path):
            # create the autostart symlink
            try:
                os.symlink('/usr/share/applications/ubuntu-mate-welcome.desktop', self._autostart_path)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while enabling autostart: ' + str(err), 0, 1)
                pass

        elif os.path.exists(self._autostart_path):
            # remove the autostart symlink
            try:
                os.unlink(self._autostart_path)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while disabling autostart: ' + str(err), 0, 1)
                pass

        self.autostart = self.autostart_check()
        dbg.stdout('Welcome', 'Auto start toggled to: ' + str(self.autostart), 1, 2)

    def check_internet_connection(self):
        url = "http://archive.ubuntu.com/"
        dbg.stdout('Network Test', 'Establishing a connection test to "' + url + '"', 1, 3)

        if arg.simulate_no_connection:
            dbg.stdout('Network Test', 'Simulation flag: Forcing no connection presence. Retrying will reset this.', 0, 1)
            arg.simulate_no_connection = False
            self.is_online = False
            return

        if arg.simulate_force_connection:
            dbg.stdout('Network Test', 'Simulation flag: Forcing a connection presence.', 0, 2)
            dbg.stdout('Network Test', 'WARNING: Do not attempt to install/remove software offline as this may cause problems!', 0, 1)
            arg.simulate_connection = False
            self.is_online = True
            return

        try:
            response = urllib.request.urlopen(url, timeout=2).read().decode('utf-8')
        except socket.timeout:
            dbg.stdout('Network Test', 'Failed. Socket timed out to URL: ' + url, 0, 1)
            self.is_online = False
        except:
            dbg.stdout('Welcome', "Couldn't establish a connection: " + url, 0, 1)
            self.is_online = False
        else:
            dbg.stdout('Welcome', 'Successfully pinged: ' + url, 1, 2)
            self.is_online = True

    def detect_graphics(self):


        # TODO: Support dual graphic cards.
        dbg.stdout('Specs', 'Detecting graphics vendor... ', 1, 3)
        try:
            output = subprocess.Popen('lspci | grep VGA', stdout=subprocess.PIPE, shell='True').communicate()[0]
            output = output.decode(encoding='UTF-8')
        except:
            # When 'lspci' does not find a VGA controller (this is the case for the RPi 2)
            dbg.stdout('Specs', "Couldn't detect a VGA Controller on this system.", 0, 1)
            output = 'Unknown'

        # Scan for and set known brand name.
        if output.find('NVIDIA') != -1:
            self.graphics_vendor = 'NVIDIA'
        elif output.find('AMD') != -1:
            self.graphics_vendor = 'AMD'
        elif output.find('Intel') != -1:
            self.graphics_vendor = 'Intel'
        elif output.find('VirtualBox') != -1:
            self.graphics_vendor = 'VirtualBox'
        else:
            self.graphics_vendor = 'Unknown'

        self.graphics_grep = repr(output)
        self.graphics_grep = self.graphics_grep.split("controller: ",1)[1]
        self.graphics_grep = self.graphics_grep.split("\\n",1)[0]
        dbg.stdout('Specs', 'Detected: ' + str(self.graphics_grep), 1, 2)

    def get_system_info(self, webkit):
        dbg.stdout('Specs', 'Gathering system specifications...', 0, 3)

        # Start collecting advanced system information in the background.
        # (Runs in own thread to prevent holding up screen)
        inxi_thread = Thread(target=self.get_inxi_info)
        inxi_thread.start()

        # Append a failure symbol beforehand in event something goes horribly wrong.
        stat_error_msg = "Could not gather data."
        html_tag = '<a data-toggle=\'tooltip\' data-placement=\'top\' title=\'' + stat_error_msg + '\'><span class=\'fa fa-warning specs-error\'></span></a>'
        for element in ['distro', 'kernel', 'motherboard', 'boot-mode', 'cpu-model', 'cpu-speed', 'arch-use',
                        'arch-supported', 'memory', 'graphics', 'filesystem', 'capacity', 'allocated-space', 'free-space']:
            app.update_page('#spec'+element, 'html', html_tag)

        # Collect basic system information
        def run_external_command(command, with_shell=False):
            if with_shell:
                raw = str(subprocess.Popen(command, stdout=subprocess.PIPE, shell=True).communicate()[0])
            else:
                raw = str(subprocess.Popen(command, stdout=subprocess.PIPE).communicate()[0])
            output = raw.replace("b'","").replace('b"',"").replace("\\n'","").replace("\\n","")
            return output

        ## Distro
        try:
            dbg.stdout('Specs', 'Gathering Data: Distribution', 1, 0)
            distro_description = run_external_command(['lsb_release','-d','-s'])
            distro_codename = run_external_command(['lsb_release','-c','-s'])
            app.update_page('#spec-distro', 'html', distro_description)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Distribution', 0, 1)

        ## Kernel
        try:
            dbg.stdout('Specs', 'Gathering Data: Kernel', 1, 0)
            kernel = run_external_command(['uname','-r'])
            app.update_page('#spec-kernel', 'html', kernel)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Kernel', 0, 1)

        ## Motherboard
        try:
            dbg.stdout('Specs', 'Gathering Data: Motherboard', 1, 0)
            motherboard_name = run_external_command(['cat','/sys/devices/virtual/dmi/id/board_name'])
            app.update_page('#spec-motherboard', 'html', motherboard_name)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Motherboard', 0, 1)

        ## CPU Details
        dbg.stdout('Specs', 'Gathering Data: CPU', 1, 0)
        try:
            cpu_model = run_external_command(['lscpu | grep "name"'], True).split(': ')[1]
            app.update_page('#spec-cpu-model', 'html', cpu_model)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Model', 0, 1)

        try:
            try:
                # Try obtaining the maximum speed first.
                cpu_speed = int(run_external_command(['lscpu | grep "max"'], True).split(': ')[1].strip(' ').split('.')[0])
            except:
                # Otherwise, fetch the CPU's MHz.
                cpu_speed = int(run_external_command(['lscpu | grep "CPU MHz"'], True).split(': ')[1].strip(' ').split('.')[0])

            app.update_page('#spec-cpu-speed', 'html', str(cpu_speed) + ' MHz')
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Speed', 0, 1)

        try:
            if self.arch == 'i386':
                cpu_arch_used = '32-bit'
            elif self.arch == 'amd64':
                cpu_arch_used = '64-bit'
            else:
                cpu_arch_used = self.arch
            app.update_page('#spec-arch-use', 'html', cpu_arch_used)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Architecture', 0, 1)

        try:
            cpu_arch_supported = run_external_command(['lscpu | grep "mode"'], True).split(': ')[1]
            app.update_page('#spec-arch-supported', 'html', cpu_arch_supported)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Supported Architectures', 0, 1)

        ## Root partition (where Distribution is installed) and the rest of that disk.
        try:
            if self.session_type == 'live':
                app.update_page('.spec-hide-live-session', 'hide')
            else:
                dbg.stdout('Specs', 'Gathering Data: Storage', 1, 0)
                ## Gather entire disk data
                root_partition = run_external_command(['mount | grep "on / "'], True).split(' ')[0]
                if root_partition[:-2] == "/dev/sd":            # /dev/sdXY
                    root_dev = root_partition[:-1]
                if root_partition[:-2] == "/dev/hd":            # /dev/hdXY
                    root_dev = root_partition[:-1]
                if root_partition[:-3] == "/dev/mmcblk":        # /dev/mmcblkXpY
                    root_dev = root_partition[:-2]
                else:
                    root_dev = root_partition[:-1]              # Generic
                disk_dev_name = root_dev.split('/')[2]
                dbg.stdout('Specs', 'Distribution is installed on disk: ' + root_dev, 1, 4)
                rootfs = os.statvfs('/')
                root_size = rootfs.f_blocks * rootfs.f_frsize
                root_free = rootfs.f_bavail * rootfs.f_frsize
                root_used = root_size - root_free
                entire_disk = run_external_command(['lsblk -b | grep "' + disk_dev_name + '" | grep "disk"'], True)
                entire_disk = int(entire_disk.split()[3])

                ## Perform calculations across units
                capacity_GB =   round(entire_disk/1000/1000/1000,1)
                capacity_GiB =  round(entire_disk/1024/1024/1024,1)
                allocated_GB =  round(root_size/1000/1000/1000,1)
                allocated_GiB = round(root_size/1024/1024/1024,1)
                used_GB =       round(root_used/1000/1000/1000,1)
                used_GiB =      round(root_used/1024/1024/1024,1)
                free_GB =       round(root_free/1000/1000/1000,1)
                free_GiB =      round(root_free/1024/1024/1024,1)
                other_GB =      round((entire_disk-root_size)/1000/1000/1000,1)
                other_GiB =     round((entire_disk-root_size)/1024/1024/1024,1)

                # Show megabytes/mebibytes (in red) if gigabytes are too small.
                if capacity_GB <= 1:
                    capacity_GB = str(round(entire_disk/1000/1000,1)) + ' ' + mb_prefix
                    capacity_GiB = str(round(entire_disk/1024/1024,1)) + ' ' + mib_prefix
                else:
                    capacity_GB = str(capacity_GB) + ' ' + gb_prefix
                    capacity_GiB = str(capacity_GiB) + ' ' + gib_prefix

                if allocated_GB <= 1:
                    allocated_GB =  str(round(root_size/1000/1000,1)) + ' ' + mb_prefix
                    allocated_GiB = str(round(root_size/1024/1024,1)) + ' ' + mib_prefix
                else:
                    allocated_GB = str(allocated_GB) + ' ' + gb_prefix
                    allocated_GiB = str(allocated_GiB) + ' ' + gib_prefix

                if used_GB <= 1:
                    used_GB =  str(round(root_used/1000/1000,1)) + ' ' + mb_prefix
                    used_GiB = str(round(root_used/1024/1024,1)) + ' ' + mib_prefix
                else:
                    used_GB = str(used_GB) + ' ' + gb_prefix
                    used_GiB = str(used_GiB) + ' ' + gib_prefix

                if free_GB <= 1:
                    free_GB =  str(round(root_free/1000/1000,1)) + ' ' + mb_prefix
                    free_GiB = str(round(root_free/1024/1024,1)) + ' ' + mib_prefix
                    app.update_page('#spec-free-space', 'addClass', 'specs-error')
                else:
                    free_GB = str(free_GB) + ' ' + gb_prefix
                    free_GiB = str(free_GiB) + ' ' + gib_prefix

                if other_GB <= 1:
                    other_GB =  str(round((entire_disk-root_size)/1000/1000,1)) + ' ' + mb_prefix
                    other_GiB = str(round((entire_disk-root_size)/1024/1024,1)) + ' ' + mib_prefix
                else:
                    other_GB = str(other_GB) + ' ' + gb_prefix
                    other_GiB = str(other_GiB) + ' ' + gib_prefix

                ## Append data to HTML.
                app.update_page('#spec-filesystem', 'html', root_partition)
                app.update_page('#spec-capacity', 'html', capacity_GB + ' <span class=\'secondary-value\'>(' + capacity_GiB + ')</span>')
                app.update_page('#spec-allocated-space', 'html',  allocated_GB + ' <span class=\'secondary-value\'>(' + allocated_GiB + ')</span>')
                app.update_page('#spec-used-space', 'html', used_GB + ' <span class=\'secondary-value\'>(' + used_GiB + ')</span>')
                app.update_page('#spec-free-space', 'html', free_GB + ' <span class=\'secondary-value\'>(' + free_GiB + ')</span>')
                app.update_page('#spec-other-space', 'html', other_GB + ' <span class=\'secondary-value\'>(' + other_GiB + ')</span>')

                ## Calculate representation across physical disk
                disk_percent_UM_used = int(round(root_used / entire_disk * 100)) * 2
                disk_percent_UM_free = int(round(root_free / entire_disk * 100)) * 2
                disk_percent_other   = (200 - disk_percent_UM_used - disk_percent_UM_free)
                dbg.stdout('Specs', ' Disk: ' + root_dev, 1, 4)
                dbg.stdout('Specs', '  -- OS Used: ' + str(root_used) + ' bytes (' + str(disk_percent_UM_used/2) + '%)', 1, 4)
                dbg.stdout('Specs', '  -- OS Free: ' + str(root_free) + ' bytes (' + str(disk_percent_UM_free/2) + '%)', 1, 4)
                dbg.stdout('Specs', '  -- Other Partitions: ' + str(entire_disk - root_size) + ' bytes (' + str(disk_percent_other/2) + '%)', 1, 4)

                app.update_page('#disk-used', 'width', str(disk_percent_UM_used) + 'px')
                app.update_page('#disk-free', 'width', str(disk_percent_UM_free) + 'px')
                app.update_page('#disk-other', 'width', str(disk_percent_other) + 'px')

        except:
            dbg.stdout('Specs', 'Failed to gather data: Storage', 0, 1)

        ## RAM
        try:
            dbg.stdout('Specs', 'Gathering Data: RAM (Memory)', 1, 0)
            ram_bytes = run_external_command(['free -b | grep "Mem:" '], True)
            ram_bytes = float(ram_bytes.split()[1])
            if round(ram_bytes / 1024 / 1024) < 1024:
                ram_xb = str(round(ram_bytes / 1000 / 1000, 1)) + ' ' + mb_prefix
                ram_xib = str(round(ram_bytes / 1024 / 1024, 1)) + ' ' + mib_prefix
            else:
                ram_xb =  str(round(ram_bytes / 1000 / 1000 / 1000, 1)) + ' ' + gb_prefix
                ram_xib = str(round(ram_bytes / 1024 / 1024 / 1024, 1)) + ' ' + gib_prefix
            ram_string = ram_xb + ' <span class=\'secondary-value\'>(' + ram_xib + ')</span>'
            app.update_page('#spec-memory', 'html', ram_string)
        except:
            dbg.stdout('Specs', 'Failed to gather data: RAM (Memory)', 0, 1)

        ## Graphics
        app.update_page('#spec-graphics', 'html', self.graphics_grep)

        ## Collect missing data differently for some architectures.
        if systemstate.arch == 'powerpc':
            ## Motherboard & Revision
            try:
                dbg.stdout('Specs', 'Gathering Data: PowerPC Motherboard', 1, 0)
                mb_model = run_external_command(['grep','motherboard','/proc/cpuinfo']).split(': ')[1]
                mb_rev = run_external_command(['grep','revision','/proc/cpuinfo']).split(': ')[1]
                app.update_page('#spec-motherboard', 'html', mb_model + ' ' + mb_rev)
            except:
                dbg.stdout('Specs', 'Failed to gather data: PowerPC Motherboard', 0, 1)

            ## CPU and Clock Speed
            try:
                dbg.stdout('Specs', 'Gathering Data: PowerPC CPU', 1, 0)
                cpu_model = run_external_command(['grep','cpu','/proc/cpuinfo']).split(': ')[1]
                cpu_speed = run_external_command(['grep','clock','/proc/cpuinfo']).split(': ')[1]
                app.update_page('#spec-cpu-model', 'html', cpu_model)
                app.update_page('#spec-cpu-speed', 'html', str(cpu_speed))
            except:
                dbg.stdout('Specs', 'Failed to gather data: PowerPC CPU', 0, 1)

            ## Device Name
            try:
                dbg.stdout('Specs', 'Gathering Data: PowerPC Model Name', 1, 0)
                mb_name = run_external_command(['grep','detected','/proc/cpuinfo']).split(': ')[1]
                app.update_page('#spec-motherboard', 'append', ' / ' + mb_name)
            except:
                dbg.stdout('Specs', 'Failed to gather data: PowerPC Model Name', 0, 1)

            ## Boot Mode / PowerMac Generation
            try:
                dbg.stdout('Specs', 'Gathering Data: PowerMac Generation', 1, 0)
                mac_generation = run_external_command(['grep','pmac-generation','/proc/cpuinfo']).split(': ')[1]
                app.update_page('#spec-boot-mode', 'html', 'Yaboot (' + mac_generation + ')')
            except:
                dbg.stdout('Specs', 'Failed to gather data: PowerMac Generation', 0, 1)

        # Check internet connectivity status.
        if self.is_online:
            app.update_page('#specs-has-net', 'show')
            app.update_page('#specs-has-no-net', 'hide')
        else:
            app.update_page('#specs-has-net', 'hide')
            app.update_page('#specs-has-no-net', 'show')

        # Change icon depending on what type of device we are using.
        if self.graphics_vendor == 'VirtualBox':
            app.update_page('#specs-device-vbox', 'show')
            app.update_page('.specs-hide-vbox', 'hide')
        elif self.session_type == 'live':
            app.update_page('#specs-live-session', 'show')
            app.update_page('.specs-live-live', 'hide')
        else:
            app.update_page('#specs-device-normal', 'show')

        # Display UEFI/BIOS boot mode.
        if systemstate.arch == 'i386' or systemstate.arch == 'amd64':
            app.update_page('#spec-boot-mode', 'html', self.boot_mode)

        # Hide root storage info if in a live session.
        if self.session_type == 'live':
            app.update_page('.spec-3', 'hide')

        # Data cached, ready to display.
        app.update_page('#specs-loading', 'fadeOut', 'fast')
        app.update_page('#specs-tabs', 'fadeIn', 'fast')
        app.update_page('#specs-basic', 'fadeIn', 'medium')
        app.update_page('#specs-busy-basic', 'fadeOut', 'fast')
        webkit.run_javascript('setCursorNormal()')

    def get_inxi_info(self):
        dbg.stdout('Specs', 'Gathering advanced system information with "inxi"...', 1, 0)
        try:
            inxi_output = str(subprocess.Popen(['inxi','-c','0','-v','5','-p','-d','-xx'], stdout=subprocess.PIPE).communicate()[0])
        except:
            dbg.stdout('Specs', 'Failed to execute collect advanced information. Is "inxi" no longer installed?', 0, 1)

        # Append advanced system information
        try:
            inxi_output = inxi_output.replace("b'","").replace("\\n","\n")
            self.inxi = inxi_output
            app.update_page('#specs-inxi', 'html', '')
            for line in inxi_output.split('\n'):
                app.update_page('#specs-inxi', 'append', line.strip('"').strip("'") + '<br>')
            app.update_page('#specs-inxi-busy', 'slideUp')
            app.update_page('#specs-inxi', 'slideDown')
            app.update_page('#specs-busy-detailed', 'fadeOut', 'fast')
            app.update_page('#specs-inxi-copy', 'slideDown')
            dbg.stdout('Specs', 'Successfully appended advanced system information.', 0, 2)
        except:
            dbg.stdout('Specs', 'Failed to append advanced system information or communicate with "inxi" process.', 0, 1)
            app.update_page('#specs-inxi-busy', 'slideUp')
            app.update_page('#specs-inxi-error', 'slideDown')



    def copy_to_clipboard(self, var):
        # Copies text to clipboard, passes 'var' containing what we'd like copying.
        if var == 'inxi':
            contents = self.inxi
        else:
            dbg.stdout('Clipboard', 'Unknown variable to copy: ' + var, 0, 1)
            return

        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
        clipboard.set_text(contents, -1)
        clipboard.store()
        dbg.stdout('Clipboard', 'Copied contents of: ' + var, 1, 2)


class DynamicApps(object):
    def __init__(self):
        # Load JSON Index into Memory
        self.reload_index()

        # Variables to remember common details.
        self.all_categories = ['Accessories', 'Education', 'Games', 'Graphics', 'Internet', 'Office', 'Programming', 'Media', 'SysTools', 'UnivAccess', 'Servers', 'MoreApps']
        self.hide_non_free = pref.get('hide_non_free', False)

        # Indicate that operations are in progress.
        self.operations_busy = False

        # Get the version of Welcome in use.
        for pkgname in systemstate.apt_cache.keys():
            if 'ubuntu-mate-welcome' in pkgname:
                systemstate.welcome_version = '0.001'
                break
        dbg.stdout('Welcome', 'Version: ' + systemstate.welcome_version, 0, 0)

    def reload_index(self):
        try:
            dbg.stdout('Apps', 'Reading index...', 1, 3)
            json_path = os.path.abspath(os.path.join(data_path, 'js/applications.json'))
            with open(json_path) as data_file:
                self.index = json.load(data_file)
                dbg.stdout('Apps', 'Successfully loaded index.', 1, 2)
        except Exception as e:
            self.index = None
            dbg.stdout('Apps', 'Software Index JSON is invalid or missing!', 0, 1)
            dbg.stdout('Apps', '------------------------------------------------------------', 1, 1)
            dbg.stdout('Apps', str(e), 1, 1)
            dbg.stdout('Apps', '------------------------------------------------------------', 1, 1)

    def set_app_info(self, category, program_id):
        self.app_name = self.index[category][program_id]['name']
        self.app_img = self.index[category][program_id]['img']
        self.app_main_package = self.index[category][program_id]['main-package']
        self.app_launch_command = self.index[category][program_id]['launch-command']
        self.app_upgrade_only = False
        try:
            if self.index[category][program_id]['upgradable']:
                self.app_upgrade_only = True
                self.app_upgrade_packages = self.index[category][program_id]['upgrade-packages']
        except:
            self.app_upgrade_only = False

        if not self.app_upgrade_only:
            self.app_install_packages = self.index[category][program_id]['install-packages']
            self.app_remove_packages = self.index[category][program_id]['remove-packages']
        self.app_description = ''
        for line in self.index[category][program_id]['description']:
            self.app_description = self.app_description + ' ' + line
        self.app_alternate_to = self.index[category][program_id]['alternate-to']
        self.app_subcategory = self.index[category][program_id]['subcategory']
        self.app_open_source = self.index[category][program_id]['open-source']
        self.app_url_info = self.index[category][program_id]['url-info']
        self.app_url_android = self.index[category][program_id]['url-android']
        self.app_url_ios = self.index[category][program_id]['url-ios']
        self.app_arch = self.index[category][program_id]['arch']
        self.app_releases = self.index[category][program_id]['releases']
        self.app_working = self.index[category][program_id]['working']

    def append_app_listing(self, category, program_id, target_element, track_subcategories=False):
        # Only list the program if it's working.
        if not self.app_working:
            dbg.stdout('Apps', ' Skipping unlisted application: ' + self.app_name, 2, 4)
            return 2

        # Only list the program if it supports the current architecture in use.
        supported = False
        supported_arch = False
        supported_release = False

        for architecture in self.app_arch.split(','):
            if architecture == systemstate.arch:
                supported_arch = True

        # Only list the program if it's available for the current release.
        for release in self.app_releases.split(','):
            if release == systemstate.codename:
                supported_release = True

        if supported_arch and supported_release:
            supported = True

        if not supported:
            dbg.stdout('Apps', ' Skipping unsupported: ' + self.app_name + ' (Only for architectures: ' + self.app_arch + ' and releases: ' + self.app_releases + ')', 2, 4)
            return 1

        # If the app has made it this far, it can be added to the grid.
        # CSS breaks with dots (.), so any must become hyphens (-).
        dbg.stdout('Apps', ' Added: ' + self.app_name, 2, 2)
        html_buffer = ''
        css_class = program_id.replace('.','-')
        css_subcategory = self.app_subcategory.replace(' ','-')

        # Icons/text to show for source fields
        source_ppa = '<span class="fa fa-cube"></span>&nbsp;'
        source_manual = '<span class="fa fa-globe"></span></a>&nbsp;'
        source_partner = '<img src="' + trans.res_dir + 'img/logos/ubuntu-mono.png" width="16px" height="16px"/>&nbsp;' + string.repo_partner
        source_multiverse = '<img src="' + trans.res_dir + 'img/logos/ubuntu-mono.png" width="16px" height="16px"/>&nbsp;' + string.repo_multiverse
        source_skip = '<img src="' + trans.res_dir + 'img/logos/ubuntu-mono.png" width="16px" height="16px"/>&nbsp;' + string.repo_ubuntu

        # "Normal" packages that can be installed/removed by the user.
        if self.app_open_source:
            html_buffer += '<div class="app-entry ' + css_class + ' filter-' + css_subcategory + '">'
        else:
            html_buffer += '<div class="app-entry ' + css_class + ' filter-' + css_subcategory + ' proprietary">'
        html_buffer += '<div class="row-fluid">'
        html_buffer += '<div class="span2 center-inside">'
        html_buffer += '<img src="' + trans.res_dir + 'img/applications/' + self.app_img + '.png">'
        html_buffer += '<span class="fa fa-check-circle fa-2x installed-check ' + css_class + '-remove"></span>'
        html_buffer += '</div><div class="span10">'
        html_buffer += '<p><b class="' + css_class + '-text">' + self.app_name + '</b></p>'

        # When queue mode is enabled, show the "plan" text here.
        html_buffer += '<h5 class="queue-plan ' + css_class + '-plan" hidden></h5>'

        html_buffer += '<p class="' + css_class + '-text">' + self.app_description + '</p>'

        # Check any "Upgrade" packages if the PPA has already been added.
        upgraded = False
        if self.app_upgrade_only:
            try:
                listname = dynamicapps.index[category][program_id]['pre-install']['all']['source-file']
                listname = listname.replace('OSVERSION',preinstallation.os_version).replace('CODENAME',preinstallation.codename)
                if os.path.exists(os.path.join('/', 'etc', 'apt', 'sources.list.d', listname+'.list')):
                    upgraded = True
                    html_buffer += '<h5 class="' + css_class + '-text"><span class="fa fa-check-circle"></span> ' + string.upgraded + '</h5>'
            except:
                pass

        if not self.app_alternate_to == None:
            html_buffer += '<ul><li class="' + css_class + '-text"><b>' + string.alternate_to + ' </b><i>' + self.app_alternate_to + '</i></li></ul>'
        html_buffer += '<p class="text-right">'
        html_buffer += '<a class="btn info-show-' + css_class + '" onclick="cmd(\'app-info-show?' + css_class + '\')"><span class="fa fa-chevron-down"></span> ' + string.show + '</a>&nbsp;'
        html_buffer += '<a hidden class="btn info-hide-' + css_class + '" onclick="cmd(\'app-info-hide?' + css_class + '\')"><span class="fa fa-chevron-up"></span> ' + string.hide + '</a>&nbsp;'

        # "Regular" packages - can be installed or removed with one-click by the user.
        if not self.app_upgrade_only:
            html_buffer += '<span class="' + css_class + '-applying"> <span class="' + css_class + '-applying-status"></span> &nbsp;<img src="' + trans.res_dir + 'img/welcome/processing.gif" width="24px" height="24px"/></span>'
            html_buffer += '<a class="' + css_class + '-install btn btn-success" onclick="cmd(\'install-appid?' + program_id + '\')"><span class="fa fa-download"></span>&nbsp; ' + string.install + '</a>&nbsp;'
            html_buffer += '<a class="' + css_class + '-reinstall btn btn-warning" onclick="cmd(\'install-appid?' + program_id + '\')" data-toggle="tooltip" data-placement="top" title="' + string.reinstall + '"><span class="fa fa-refresh"></span></a>&nbsp;'
            html_buffer += '<a class="' + css_class + '-remove btn btn-danger" onclick="cmd(\'remove-appid?' + program_id + '\')" data-toggle="tooltip" data-placement="top" title="' + string.remove + '"><span class="fa fa-trash"></span></a>&nbsp;'

        # "Upgradable" packages - usually pre-installed but have a more up-to-date repository.
        if self.app_upgrade_only:
            dbg.stdout('Apps', 'Upgrade: ' + self.app_name, 2, 4)
            if not upgraded:
                html_buffer += '<a class="' + css_class + '-upgrade btn btn-warning" onclick="cmd(\'upgrade-appid?' + program_id + '\')"><span class="fa fa-level-up"></span>&nbsp; ' + string.upgrade + '</a>&nbsp;'

        # Add a button to undo an action in the queue.
        html_buffer += '<a class="' + css_class + '-undo btn btn-inverse" onclick="cmd(\'queue-drop?' + program_id + '\')" style="display:none"><span class="fa fa-undo"></span> ' + string.undo + '</a>'

        # Add a button to launch, depending on the app:
        if not self.app_launch_command == None:
            html_buffer += '<a class="' + css_class + '-launch btn btn-inverse" onclick="cmd(\'launch-appid?' + program_id + '\')"><img src="' + trans.res_dir + 'img/applications/' + self.app_img + '.png" width="20px" height="20px" />&nbsp; ' + string.launch + '</a>&nbsp;'

        # More details section.
        html_buffer += '</p><div hidden class="details-' + css_class + '">'

        ## Determine string for license
        if self.app_open_source:
            license_string = _('Open Source')
        else:
            license_string = _('Proprietary')

        ## Determine supported platforms
        platform_string = ''
        for arch in self.app_arch.split(','):
            if arch == 'i386':
                platform_string += '<span class="i386"><span class="fa fa-laptop"></span> 32-bit</span> &nbsp;&nbsp;'
            elif arch =='amd64':
                platform_string += '<span class="amd64"><span class="fa fa-laptop"></span> 64-bit</span> &nbsp;&nbsp;'
            elif arch =='armhf':
                platform_string += '<span class="armhf"><span class="fa fa-tv"></span> aarch32 (ARMv7)</span> &nbsp;&nbsp;'
            elif arch =='powerpc':
                platform_string += '<span class="powerpc"><span class="fa fa-desktop"></span> PowerPC</span> &nbsp;&nbsp;'

        ## Add Android / iOS app links if necessary.
        if not self.app_url_android == None:
            platform_string += '<a onclick="cmd(\'link?' + self.app_url_android + '\')"><span class="fa fa-android"></span> Android</a> &nbsp;&nbsp;'

        if not self.app_url_ios == None:
            platform_string += '<a onclick="cmd(\'link?' + self.app_url_ios + '\')"><span class="fa fa-apple"></span> iOS</a> &nbsp;&nbsp;'

        ## Add details about the source of this file.
        try:
            preinstall = dynamicapps.index[category][program_id]['pre-install']
            codenames = list(preinstall.keys())
            target = None
            for name in codenames:
                if name == systemstate.codename:
                    target = name
                    break
            if not target:
                    target = 'all'

            methods = preinstall[target]['method'].split('+')
            self.source_info = []
            if len(methods) > 1:
                multiple_sources = True
            else:
                multiple_sources = False

            for method in methods:
                if method == 'skip':
                    self.source_info.insert(0, source_skip)

                elif method == 'partner-repo':
                    self.source_info.insert(0, source_partner)

                elif method == 'multiverse-repo':
                    self.source_info.insert(0, source_multiverse)

                elif method == 'ppa':
                    ppa = preinstall[target]['enable-ppa']
                    ppa_author = ppa.split(':')[1].split('/')[0]
                    ppa_archive = ppa.split(':')[1].split('/')[1]
                    self.source_info.insert(0, source_ppa + ' <a onclick="cmd(\'link?https://launchpad.net/~' + ppa_author + '/+archive/ubuntu/' + ppa_archive + '\')">' + ppa + '</a>')

                elif method == 'manual':
                    apt_source = ''.join(preinstall[target]['apt-sources'])
                    manual_text = source_manual + ' ' + string.unknown
                    for substring in apt_source.split(' '):
                        if substring[:4] == 'http':
                            apt_source = substring.replace('OSVERSION',preinstallation.os_version).replace('CODENAME',preinstallation.codename)
                            manual_text = source_manual + ' ' + apt_source
                            break
                    self.source_info.insert(0, manual_text)
        except:
            dbg.stdout('Apps', 'Failed to process pre-configuration for: ' + program_id, 0, 1)
            self.source_info = [string.unknown]

        ## Write contents of the table.
        html_buffer += '<table class="more-details table table-striped">'
        html_buffer += '<tr><th>' + string.license + '</th><td>' + license_string + '</td></tr>'
        html_buffer += '<tr><th>' + string.platform + '</th><td>' + platform_string + '</td></tr>'
        html_buffer += '<tr><th>' + string.category + '</th><td>' + self.app_subcategory + '</td></tr>'

        ## Add a website URL if there is one.
        if self.app_url_info:
            html_buffer += '<tr><th>' + string.website + '</th><td><a onclick="cmd(\'link?' + self.app_url_info + '\')">' + self.app_url_info + '</a></td></tr>'

        ## Add the source for this application.
        if multiple_sources:
            html_buffer += '<tr><th>' + string.source + '</th><td><ul>'
            for item in self.source_info:
                html_buffer += '<li>' + item + '</li>'
            html_buffer += '</td></tr></ul>'
        else:
            html_buffer += '<tr><th>' + string.source + '</th><td>' + self.source_info[0] + '</td></tr>'

        ## Add a screenshot if there is any.
        ## Images should be labelled the same as 'img' and increment starting at 1.
        screenshots = 1
        screenshots_end = False
        screenshot_buffer = ''
        while not screenshots_end:
            screenshot_img = 'img/applications/screenshots/' + self.app_img + '-' + str(screenshots) + '.jpg'
            screenshot_path = os.path.join(data_path, screenshot_img)
            if os.path.exists(screenshot_path):
                screenshot_buffer = screenshot_buffer + '<a class="screenshot-link" onclick="cmd(\'screenshot?' + self.app_img + '-' + str(screenshots) + '\')"><img src="' + trans.res_dir + screenshot_img + '" class="screenshot"/></a>'
                screenshots = screenshots + 1
            else:
                screenshots_end = True

        if not screenshots == 1:
            html_buffer += '<tr><th>' + string.screenshot + '</th><td>' + screenshot_buffer + '</td></tr>'

        html_buffer += '</table>'

        # End the div's for this application.
        html_buffer += '</div><br><hr class="soften"></div></div></div>'

        # Append buffer to page
        app.update_page(target_element, 'append', html_buffer)
        app.update_page('.info-hide-'+css_class, 'hide')

    def populate_categories(self, webkit):
        ''' List all of the applications supported on the current architecture. '''
        str_nothing_here = _("Sorry, Welcome could not feature any software for this category that is compatible on this system.")
        total_added = 0
        total_skipped = 0
        total_unsupported = 0

        # Don't attempt to continue if the index is missing/incorrectly parsed.
        if not self.index:
            dbg.stdout('Apps', 'Application index not loaded. Cannot populate categories.', 0, 1)
            return

        # Get the app data from each category and list them.
        for category in self.all_categories:
            dbg.stdout('Apps', ' ------ Processing: ' + category + ' ------', 2, 0)

            # Convert to a list to work with. Sort alphabetically.
            category_items = list(self.index[category].keys())
            category_items.sort()

            # Keep a count of apps in case there are none to list.
            apps_here = 0

            # Keep track of the subcategories of the apps in this category so we can filter them.
            self.subcategories = []

            # Enumerate each program in this category.
            for program_id in category_items:
                self.set_app_info(category, program_id)
                return_code = self.append_app_listing(category, program_id, '#'+category)

                # Successfully added application
                if return_code == 1:
                    total_unsupported = total_unsupported + 1
                elif return_code == 2:
                    total_skipped = total_skipped + 1
                else:
                    # Keep track of how many apps added.
                    apps_here = apps_here + 1
                    total_added = total_added + 1
                    # Add to filters.
                    self.subcategories.append(self.app_subcategory)

            # Display a message if there is nothing for this category.
            if apps_here == 0:
                app.update_page('#'+category, 'append', "<p class='center'><span class='fa fa-warning'></span>&nbsp; " + str_nothing_here + "</p>")

            # Post actions to page
            ## Colour the architecture currently in use.
            app.update_page('.'+systemstate.arch, 'addClass', 'arch-in-use')

            # Process filters for this category.
            filters = list(set(self.subcategories))
            filters.sort()
            for string in filters:
                css_subcategory = string.replace(' ','-')
                app.update_page('#Filter-'+category, 'append', '<option value="' + css_subcategory + '">' + string + '</option>')

        # "Stats for nerds"
        total_apps = total_added + total_skipped + total_unsupported
        dbg.stdout('Apps', '----------------------------------------', 1, 4)
        dbg.stdout('Apps', 'Applications added: ' + str(total_added), 1, 4)
        dbg.stdout('Apps', 'Applications unsupported on this architecture: ' + str(total_unsupported), 1, 4)
        dbg.stdout('Apps', 'Applications that are broken or not suitable for inclusion: ' + str(total_skipped), 1, 4)
        dbg.stdout('Apps', 'Total number of applications: ' + str(total_apps), 1, 4)
        dbg.stdout('Apps', '----------------------------------------', 1, 4)

    def populate_featured_apps(self, webkit):
        dbg.stdout('Apps', '---- Populating Featured Apps Grid ----', 2, 0)
        # Randomly generate a list of apps to feature if supported on this architecture.
        possible_apps = []
        for category in self.all_categories:
            category_items = list(self.index[category].keys())
            for program_id in category_items:
                if systemstate.arch in self.index[category][program_id]['arch']:
                    possible_apps.append(self.index[category][program_id]['img'])

        random.shuffle(possible_apps)
        for no in range(1,18):
            random_img = possible_apps[no]
            dbg.stdout('Apps', str(no) + '. ' + random_img, 2, 4)
            app.update_page('#featured-grid', 'append', '<img src="' + trans.res_dir + 'img/applications/' + random_img + '.png" id="appIcon' + str(no) + '" class="grid-hidden" />')
        webkit.run_javascript("initGrid();")
        dbg.stdout('Apps', '------------------', 2, 4)

    def modify_app(self, webkit, action, program_id):
        ''' Installs, removes or upgrades an application. '''
        # Either:
        #   -   Queue the application for install/remove later. Only in Boutique.
        #   -   Perform a one click operation.
        if queue.is_enabled() and app.current_page == 'software.html':
            queue.add_item(program_id, action)

        else:
            # Indicate changes are in progress.
            css_class = program_id.replace('.','-')
            app.update_page('.'+css_class+'-applying', 'show')
            app.update_page('.'+css_class+'-launch', 'hide')
            app.update_page('.'+css_class+'-install', 'hide')
            app.update_page('.'+css_class+'-reinstall', 'hide')
            app.update_page('.'+css_class+'-remove', 'hide')
            app.update_page('.'+css_class+'-upgrade', 'hide')
            app.update_page('.'+css_class+'-text', 'css', 'color', '#000')

            # Asynchronous apt process - perform any pre-installations.
            if action == 'install':
                app.update_page('.'+css_class+'-applying-status', 'html', string.install_text)
                preinstallation.process_packages(program_id, 'install')
            elif action == 'remove':
                app.update_page('.'+css_class+'-applying-status', 'html', string.remove_text)
                preinstallation.process_packages(program_id, 'remove')
            elif action == 'upgrade':
                app.update_page('.'+css_class+'-applying-status', 'html', string.upgrade_text)
                preinstallation.process_packages(program_id, 'upgrade')
            else:
                dbg.stdout('Apps', 'An unknown action was requested.', 0, 1)

            # Refresh the page to reflect changes (if any).
            systemstate.apt_cache.close()
            systemstate.apt_cache = apt.Cache()
            self.update_app_status(webkit, program_id)

    def is_app_installed(self, program_id):
        main_package = self.get_attribute_for_app(program_id, 'main-package')
        try:
            if systemstate.apt_cache[main_package].is_installed:
                dbg.stdout('Apt', 'Package "' + main_package + '" is present.', 1, 4)
                return True
            else:
                dbg.stdout('Apt', 'Package "' + main_package + '" is not installed.', 1, 4)
                return False
        except:
            dbg.stdout('Apt', 'Package "' + main_package + '" not available. Considered not installed.', 1, 4)
            return False

    def update_app_status(self, webkit, program_id):
        ''' Update the web page for an individual application. '''

        # Don't attempt to continue if the index is missing/incorrectly parsed.
        if not self.index:
            dbg.stdout('Apps', 'Application index not loaded. Cannot update application status.', 0, 1)
            return

        # Check whether the application is installed or not.
        installed = self.is_app_installed(program_id)
        main_package = self.get_attribute_for_app(program_id, 'main-package')

        # Replace any dots with dashes, as they are unsupported in CSS.
        css_class = program_id.replace('.','-')

        # Show/hide other buttons for this application.
        app.update_page('.'+css_class+'-applying', 'hide')
        app.update_page('.'+css_class+'-undo', 'hide')
        app.update_page('.'+css_class+'-plan', 'slideUp', 'fast')
        app.update_page('.'+css_class+'-plan', 'removeClass', 'install')
        app.update_page('.'+css_class+'-plan', 'removeClass', 'remove')

        if installed:
            app.update_page('.'+css_class+'-launch', 'show')
            app.update_page('.'+css_class+'-install', 'hide')
            app.update_page('.'+css_class+'-reinstall', 'show')
            app.update_page('.'+css_class+'-remove', 'show')
            app.update_page('.'+css_class+'-upgrade', 'show')
        else:
            app.update_page('.'+css_class+'-launch', 'hide')
            app.update_page('.'+css_class+'-install', 'show')
            app.update_page('.'+css_class+'-reinstall', 'hide')
            app.update_page('.'+css_class+'-remove', 'hide')
            app.update_page('.'+css_class+'-upgrade', 'hide')

    def update_all_app_status(self, webkit):
        ''' Update the webpage whether all indexed applications are installed or not. '''

        # Don't attempt to continue if the index is missing/incorrectly parsed.
        if not self.index:
            dbg.stdout('Apps', 'Application index not loaded. Cannot update page.', 0, 1)
            return

        # Enumerate each program and check each one from the index.
        dbg.stdout('Apps', '---- Checking cache for installed applications ----', 2, 0)
        for category in self.all_categories:
            category_items = list(self.index[category].keys())
            for program_id in category_items:
                main_package = self.index[category][program_id]['main-package']
                # Only check if it's supported on this architecture.
                if systemstate.arch in self.index[category][program_id]['arch']:
                    self.update_app_status(webkit, program_id)
                else:
                    continue
        dbg.stdout('Apps', '----------------------------------------', 2, 0)

    def get_attribute_for_app(self, requested_id, attribute):
        ''' Retrieves a specific attribute from a listed application,
            without specifying its category. '''
        for category in list(self.index.keys()):
            category_items = list(self.index[category].keys())
            for program_id in category_items:
                if program_id == requested_id:
                    if not attribute == 'category':
                        return self.index[category][program_id][attribute]
                    else:
                        return category

    def launch_app(self, appid):
        ''' Launch an application directly from Welcome '''
        program_name = self.get_attribute_for_app(appid, 'name')
        program_command = self.get_attribute_for_app(appid, 'launch-command')
        dbg.stdout('Apps', 'Launching "' + program_name + '... " (Command: "' + program_command + '").', 0, 3)
        try:
            subprocess.Popen(program_command.split(' '))
        except:
            dbg.stdout('Apps', 'Failed to execute: ' + program_command, 0, 1)
            title = string.boutique
            ok_label = _("OK")
            text_error = _("An error occurred while launching PROGRAM_NAME. Please consider re-installing the application.").replace('PROGRAM_NAME', program_name) + \
                            '\n\n' + _("Command:") + ' "' + program_command + '"'
            messagebox = subprocess.Popen(['zenity',
                         '--error',
                         '--title=' + title,
                         "--text=" + text_error,
                         "--ok-label=" + ok_label,
                         '--window-icon=error',
                         '--timeout=15'])

    def toggle_non_free(self):
        # Toggles visibility of non-free software.
        if self.hide_non_free:
            for element in ['#nonFreeCheckBox', '#pref-non-free']:
                app.update_page(element, 'removeClass', 'fa-square')
                app.update_page(element, 'addClass', 'fa-check-square')
        else:
            for element in ['#nonFreeCheckBox', '#pref-non-free']:
                app.update_page(element, 'addClass', 'fa-square')
                app.update_page(element, 'removeClass', 'fa-check-square')

    def apply_filter(self, webkit, filter_value, nonfree_toggle=False):
        sub_css_class = 'filter-' + filter_value

        if nonfree_toggle:
            # Toggle the option on/off
            if self.hide_non_free:
                self.hide_non_free = False
                pref.set('hide_non_free', False)
            else:
                self.hide_non_free = True
                pref.set('hide_non_free', True)
            self.toggle_non_free()

        if filter_value == 'none':
            dbg.stdout('Apps', 'Filter reset.', 1, 4)
            app.update_page('.app-entry', 'show')
            if self.hide_non_free:
                dbg.stdout('Apps', 'Hiding all proprietary software.', 1, 4)
                app.update_page('.proprietary', 'hide')
            return
        else:
            dbg.stdout('Apps', 'Applying filter: ' + filter_value, 1, 4)
            app.update_page('.app-entry', 'hide')

            for category in self.all_categories:
                category_items = list(self.index[category].keys())
                for program_id in category_items:
                    app_subcategory = self.index[category][program_id]['subcategory'].replace(' ','-')
                    app_open_source = self.index[category][program_id]['open-source']

                    # If the application is closed source and we're told to hide it.
                    if not app_open_source and self.hide_non_free:
                        app.update_page('.' + program_id.replace('.','-'), 'hide')
                        continue

                    # Only show if subcategory matches.
                    if app_subcategory.replace(' ','-') == filter_value:
                        app.update_page('.' + program_id.replace('.','-'), 'show')

    def show_screenshot(self, filename):
        ssw = ScreenshotWindow(filename)

    def populate_news(self, webkit):
        try:
            dbg.stdout('Apps', 'Reading News...', 1, 3)
            json_path = os.path.abspath(os.path.join(data_path, 'js/news.json'))
            with open(json_path) as data_file:
                self.news = json.load(data_file)
        except Exception as e:
            self.news = None
            dbg.stdout('Apps', ' News JSON is invalid or missing!', 0, 1)
            dbg.stdout('Apps', "------------------------------------------------------------", 2, 1)
            dbg.stdout('Apps', "Exception:", 2, 1)
            dbg.stdout('Apps', str(e), 2, 1)
            dbg.stdout('Apps', "------------------------------------------------------------", 2, 1)
            return

        # These functions are used later

        # Raw reasons → Human translatable text
        def get_reason_string(reason):
            if reason == "new-source":
                return _("Uses a new or updated source.")
            elif reason == "add-source":
                return _("Now works for various versions of Ubuntu.")
            elif reason == "snappy":
                return _("Now a snappy package.")
            elif reason == "general":
                return _("General maintenance.")
            elif reason == "bad-source":
                return _("Broken or problematic source.")
            elif reason == "no-source":
                return _("Not yet available for some releases.")
            elif reason == "broken":
                return _("No longer works for some releases.")
            elif reason == "unstable":
                return _("Not suitable for production machines.")
            elif reason == "testing":
                return _("Requires further testing.")
            elif reason == "not-nice":
                return _("Does not meet our standards to be featured.")
            else:
                return reason

        # Raw categories → Human translatable categories
        def get_category_string(category):
            if category == "Accessories":
                return string.accessories
            elif category == "Education":
                return string.education
            elif category == "Games":
                return string.games
            elif category == "Graphics":
                return string.graphics
            elif category == "Internet":
                return string.internet
            elif category == "Office":
                return string.office
            elif category == "Programming":
                return string.programming
            elif category == "Media":
                return string.media
            elif category == "SysTools":
                return string.systools
            elif category == "UnivAccess":
                return string.univaccess
            elif category == "Servers":
                return string.servers
            else:
                # Includes "Unlisted"
                return string.misc

        # Begin generating the HTML to append.
        news_buffer = '<hr class="soften">'
        news_versions = list(self.news.keys())
        news_versions.sort(reverse=True)
        for version in news_versions:
            news_buffer = news_buffer + '<h4>' + version + '</h4><div class="news-list-version">'

            # Create "Added" list.
            try:
                list_add = self.news[version]['add']
                list_add.sort()
                news_buffer = news_buffer + '<h5 id="news-add" class="news-list-version"><span class="fa fa-star"></span> ' + string.added + '</h5>'
                news_buffer = news_buffer + '<div class="news-list-items"><ul>'
                for item_id in list_add:
                    # Extract it's attributes.
                    try:
                        item_name = self.get_attribute_for_app(item_id, 'name')
                        item_img = self.get_attribute_for_app(item_id, 'img')
                        item_category_raw = self.get_attribute_for_app(item_id, 'category')
                        item_category = get_category_string(item_category_raw)
                        news_buffer = news_buffer + '<li><img src="' + trans.res_dir + 'img/applications/' + item_img + '.png" width="16px" height="16px"/> ' + item_name + '<span class="news-reason"> (' + item_category + ')</span></li>'
                    except Exception as e:
                        dbg.stdout('Apps', 'Failed to process news item: ' + item_id, 0, 1)
                        dbg.stdout('Apps', 'Exception: ' + str(e), 2, 1)
                news_buffer = news_buffer + '</ul></div>'
            except:
                pass

            # Create "Fixes/Updates" list.
            try:
                list_fix = list(self.news[version]['fix'].keys())
                list_fix.sort()
                news_buffer = news_buffer + '<h5 id="news-fix" class="news-list-version"><span class="fa fa-wrench"></span> ' + string.fixed + '</h5>'
                news_buffer = news_buffer + '<div class="news-list-items"><ul>'
                for item_id in list_fix:
                    try:
                        item_name = self.get_attribute_for_app(item_id, 'name')
                        item_img = self.get_attribute_for_app(item_id, 'img')
                        item_reason = get_reason_string(self.news[version]['fix'][item_id])
                        news_buffer = news_buffer + '<li><img src="' + trans.res_dir + 'img/applications/' + item_img + '.png" width="16px" height="16px"/> ' + item_name + '<span class="news-reason">-- ' + item_reason + '</span></li>'
                    except Exception as e:
                        dbg.stdout('Apps', 'Failed to process news item: ' + item_id, 0, 1)
                        dbg.stdout('Apps', 'Exception: ' + str(e), 2, 1)
                news_buffer = news_buffer + '</ul></div>'
            except:
                pass

            # Create "Removed" list.
            try:
                list_del = list(self.news[version]['del'].keys())
                list_del.sort()
                news_buffer = news_buffer + '<h5 id="news-del" class="news-list-version"><span class="fa fa-remove"></span> ' + string.removed + '</h5>'
                news_buffer = news_buffer + '<div class="news-list-items"><ul>'
                for item_name in list_del:
                    try:
                        item_img = 'unknown'
                        item_reason = get_reason_string(self.news[version]['del'][item_name])
                        news_buffer = news_buffer + '<li><img src="' + trans.res_dir + 'img/applications/' + item_img + '.png" width="16px" height="16px"/> ' + item_name + '<span class="news-reason">-- ' + item_reason + '</span></li>'
                    except Exception as e:
                        dbg.stdout('Apps', 'Failed to process news item: ' + item_name, 0, 1)
                        dbg.stdout('Apps', 'Exception: ' + str(e), 2, 1)
                news_buffer = news_buffer + '</ul></div>'
            except:
                pass
            news_buffer = news_buffer + '</div><hr class="soften">'
        app.update_page('#News-Content', 'html', news_buffer)
        dbg.stdout('Apps', 'Successfully loaded news.', 1, 2)

    def perform_search(self, webkit, terms):
        app.update_page('#search-empty', 'hide')
        app.update_page('#search-total', 'hide')
        # Do not allow blank searches.
        if terms == '':
            app.update_page('#search-results', 'fadeIn')
            app.update_page('#search-results', 'html', '<div class="alert alert-danger"><h5>' + string.search_begin + '</h5></div>')
            return

        # Do not search if less than 3 characters
        if len(terms) < 3:
            app.update_page('#search-results', 'fadeIn')
            app.update_page('#search-results', 'html', '<div class="alert alert-danger"><h5>' + string.search_short + '</h5></div>')
            return

        # Start Searching!
        dbg.stdout('Apps', 'Searching for: ' + terms, 1, 4)
        app.update_page('#navigation-sub-title', 'html', string.search + ': ' + terms)
        terms.lower()
        app.update_page('#search-results', 'hide')
        app.update_page('#search-results', 'html', ' ')
        total_results = 0
        hidden_results = 0
        for category in self.all_categories:
            app_id = list(self.index[category].keys())
            app_id.sort()

            # Gather sources to search for each app in this category
            # Also search case insensitive
            for program_id in app_id:
                name = self.index[category][program_id]['name'].lower()
                desc = self.index[category][program_id]['description']
                desc = ' '.join(desc).lower()
                alto = str(self.index[category][program_id]['alternate-to']).lower()

                # Any matches? List them!
                app_matched = False
                matched_results = []
                for term in terms.split(' '):
                    matched_results.append(program_id.find(term))
                    matched_results.append(name.find(term))
                    matched_results.append(desc.find(term))
                    matched_results.append(alto.find(term))
                    for status in matched_results:
                        if status != -1:
                            app_matched = True
                            break

                if app_matched:
                    # Skip this if user doesn't want non-free software.
                    oss = self.index[category][program_id]['open-source']
                    if self.hide_non_free and not oss:
                        hidden_results = hidden_results + 1
                        continue

                    # Display result to user, if it works on the system (return code 0)
                    self.set_app_info(category, program_id)
                    return_code = self.append_app_listing(category, program_id, '#search-results')
                    if not return_code == 1 or return_code == 2:
                        dynamicapps.update_app_status(self, program_id)
                        total_results = total_results + 1

        if total_results == 0:
            app.update_page('#search-empty', 'fadeIn')
            if hidden_results > 0:
                app.update_page('#search-retry-nonfree', 'show')
            else:
                app.update_page('#search-retry-nonfree', 'hide')
        else:
            app.update_page('#search-results', 'fadeIn')
            app.update_page('#search-total', 'fadeIn')
            app.update_page('#search-total', 'html', '<b>' + str(total_results) + ' ' + _("applications found.") + '</b>')

            # If non-free filtering is enabled, inform of how many apps were hidden.
            if self.hide_non_free and hidden_results > 0:
                app.update_page('#search-total', 'append', '&nbsp;<a onclick="searchAgainNonFree()">' + str(hidden_results) + ' ' + _("proprietary applications are hidden.") + '</a>')


class ChangesQueue(object):
    def __init__(self):
        # Reset queues
        self.reset()

        # Whether PreInstallation class should inform us to update the cache.
        # (For software that adds/removes a repository)
        self.must_update_cache = False

        # Card template
        self.card_template = '<div class="card-PROGRAM_ID queue-card">' + \
                                 '<img class="icon" src="img/applications/PROGRAM_IMG.png"/>' + \
                                 '<span class="title">PROGRAM_NAME</span>' + \
                                 '<div class="status">' + \
                                     '<span class="status-PROGRAM_ID"> DEFAULT_TEXT </span> ' + \
                                     '<a class="drop" onclick="cmd(\'queue-drop?PROGRAM_ID\')" data-toggle="tooltip" data-placement="top" title="' + string.cancel + '"><span class="fa fa-times fa-2x"></span></a>' + \
                                 '</div>' + \
                             '</div>'

    def reset(self):
        # Intended when re-entering the Boutique from the main menu.
        self.install_queue = []
        self.remove_queue = []
        self.queue_count = 0
        self.must_update_cache = False

    def add_item(self, program_id, queue):
        # User adds to the bulk queue
        # Is this the first item? Hide the help text.
        if len(self.install_queue) + len(self.remove_queue) == 0:
            app.update_page('#queue-empty','slideUp')
            app.update_page('#queue-options','slideDown')

        # What's the plan?
        if queue == 'install':
            self.install_queue.append(program_id)
            self.ui_add_card(program_id, 'install')
            plan_html = '<span class="fa fa-download"></span> ' + string.queue_install
            plan_css = 'install'
            app.update_page('#navigation-queue', 'jAnimateOnce', 'queue-glow-add')

        elif queue == 'remove':
            self.remove_queue.append(program_id)
            self.ui_add_card(program_id, 'remove')
            plan_html = '<span class="fa fa-trash"></span> ' + string.queue_remove
            plan_css = 'remove'
            app.update_page('#navigation-queue', 'jAnimateOnce', 'queue-glow-remove')

        else:
            dbg.stdout('Queue', 'Unrecognised request: "' + queue + '" does not exist. "' + program_id + '" ignored.', 0, 1)
            return

        self.queue_count += 1
        self.ui_update_count()
        dbg.stdout('Queue', 'Added "' + program_id + '" to "' + queue + '" queue.', 1, 3)

        # Update UI in application listings.
        css_class = program_id.replace('.','-')
        app.update_page('.'+css_class+'-launch', 'hide')
        app.update_page('.'+css_class+'-install', 'hide')
        app.update_page('.'+css_class+'-reinstall', 'hide')
        app.update_page('.'+css_class+'-remove', 'hide')
        app.update_page('.'+css_class+'-upgrade', 'hide')
        app.update_page('.'+css_class+'-undo', 'show')
        app.update_page('.'+css_class+'-plan', 'slideDown', 'fast')
        app.update_page('.'+css_class+'-plan', 'html', plan_html)
        app.update_page('.'+css_class+'-plan', 'addClass', plan_css)

        # Zoom the application into the queue.
        img = dynamicapps.get_attribute_for_app(program_id, 'img')
        app.update_page('#navigation-right', 'append', '<img src="' + data_path + 'img/applications/' + img + '.png" class="queue-zoom-icon"/>')

    def drop_item(self, program_id):
        # User no longer wants changes to this program.
        try:
            self.install_queue.remove(program_id)
            dbg.stdout('Queue', 'Dropped "' + program_id + '" from install queue.', 1, 3)
        except:
            pass

        try:
            self.remove_queue.remove(program_id)
            dbg.stdout('Queue', 'Dropped "' + program_id + '" from remove queue.', 1, 3)
        except:
            pass

        self.ui_remove_card(program_id)
        dynamicapps.update_app_status(app.webkit, program_id)
        self.queue_count -= 1
        self.ui_update_count()

        # Is this the last card? Show the help text if so.
        if len(self.install_queue) + len(self.remove_queue) == 0:
            app.update_page('#queue-empty','slideDown')
            app.update_page('#queue-options','slideUp')

    def clear(self):
        dbg.stdout('Queue', 'Clearing queue...', 1, 3)
        while len(self.install_queue) > 0:
            program_id = self.install_queue[0]
            self.drop_item(program_id)

        while len(self.remove_queue) > 0:
            program_id = self.remove_queue[0]
            self.drop_item(program_id)

        self.install_queue = []
        self.remove_queue = []
        dbg.stdout('Queue', 'Queue cleared.', 1, 2)

        # Reset UI elements
        app.update_page('#queue-btn-apply', 'show')
        app.update_page('#queue-btn-clear', 'show')
        app.update_page('#queue-btn-reset', 'hide')

        # Unlock/Restore UI if applicable
        app.update_page('#navigation-right', 'removeClass', 'disabled')
        app.update_page('#category-tabs', 'removeClass', 'disabled')
        app.update_page('#queue-btn-reset', 'fadeOut')
        app.update_page('#queue-error', 'fadeOut')

    def apply(self):
        # "Hello, would you like a bag?"
        #
        # Priority:     Remove first -->  Install
        dbg.stdout('Queue', 'Applying changes...', 0, 3)

        # Lock/Update UI
        app.update_page('#navigation-right', 'addClass', 'disabled')
        app.update_page('#category-tabs', 'addClass', 'disabled')
        app.webkit.run_javascript('smoothFade("#queue-options","#queue-busy")')
        app.update_page('#queue-error', 'fadeOut')
        app.update_page('.drop', 'hide')

        # Function to check whether an application's change was successful.
        self.bulk_all_good = True
        def check_app_state(self, program_id, check_for_state):
            systemstate.reload_cache()
            installed = dynamicapps.is_app_installed(program_id)

            if installed and check_for_state == 'install':
                self.ui_update_card(program_id, '<span class="fa fa-check"></span> ' + string.install_success, 'success')

            elif not installed and check_for_state == 'install':
                self.ui_update_card(program_id, '<span class="fa fa-warning"></span> ' + string.install_fail, 'error')
                self.bulk_all_good = False

            elif not installed and check_for_state == 'remove':
                self.ui_update_card(program_id, '<span class="fa fa-check"></span> ' + string.remove_success, 'success')

            elif installed and check_for_state == 'remove':
                self.ui_update_card(program_id, '<span class="fa fa-warning"></span> ' + string.remove_fail, 'error')
                self.bulk_all_good = False

        # Uninstall applications first
        if len(self.remove_queue) > 0:
            # Preconfiguration - delete sources/ppa if applicable
            current = 0
            total = len(self.remove_queue)
            for program_id in self.remove_queue:
                name = dynamicapps.get_attribute_for_app(program_id, 'name')
                img  = trans.res_dir + 'img/applications/' + dynamicapps.get_attribute_for_app(program_id, 'img') + '.png'
                self.ui_update_progress(string.queue_prepare_remove + ' <img src="' + img + '" width="16px" height="16px"/> ' + name, current, total)
                preinstallation.process_packages(program_id, 'remove', True)
                current += 1

            # Remove each application's packages
            current = 0
            total = len(self.remove_queue)
            for program_id in self.remove_queue:
                name = dynamicapps.get_attribute_for_app(program_id, 'name')
                img  = trans.res_dir + 'img/applications/' + dynamicapps.get_attribute_for_app(program_id, 'img') + '.png'
                packages = dynamicapps.get_attribute_for_app(program_id, 'remove-packages').split(',')

                self.ui_update_progress(string.queue_removing + ' <img src="' + img + '" width="16px" height="16px"/> ' + name, current, total)

                transaction = SimpleApt(packages, 'remove')
                transaction.remove_packages()
                check_app_state(self, program_id, 'remove')
                current += 1

        # Install applications next
        if len(self.install_queue) > 0:
            # Pre-configuration - add sources/ppa if applicable
            current = 0
            total = len(self.remove_queue)
            for program_id in self.install_queue:
                self.ui_update_progress(string.queue_prepare_install + ' ' + dynamicapps.get_attribute_for_app(program_id, 'name'))
                preinstallation.process_packages(program_id, 'install', True)
                current += 1

            # Update the cache (in case of repository changes)
            if self.must_update_cache:
                self.ui_update_progress(string.updating_cache)
                update_repos()
                systemstate.reload_cache()

            # Remove each application's packages
            current = 0
            total = len(self.install_queue)
            for program_id in self.install_queue:
                name = dynamicapps.get_attribute_for_app(program_id, 'name')
                img  = trans.res_dir + 'img/applications/' + dynamicapps.get_attribute_for_app(program_id, 'img') + '.png'
                packages = dynamicapps.get_attribute_for_app(program_id, 'install-packages').split(',')

                self.ui_update_progress(string.queue_installing + ' <img src="' + img + '" width="16px" height="16px"/> ' + name, current, total)

                transaction = SimpleApt(packages, 'install')
                transaction.install_packages()
                check_app_state(self, program_id, 'install')
                current += 1

        # Update UI, but do not unlock until user acknowledges "Finished".
        app.webkit.run_javascript('smoothFade("#queue-busy","#queue-options")')
        app.update_page('#queue-btn-apply', 'hide')
        app.update_page('#queue-btn-clear', 'hide')
        app.update_page('#queue-btn-reset', 'show')

        # Show a warning when something didn't go right.
        if not self.bulk_all_good:
            app.update_page('#queue-error', 'fadeIn')

    def ui_update_progress(self, string, current=0, total=0):
        app.update_page('#queue-status', 'html', string)
        if not current == 0:
            percent = str(int((current / total) * 100)) + '%'
            app.update_page('#queue-bar', 'width', percent)
            app.update_page('#queue-bar', 'fadeIn', 'fast')
        else:
            percent = '--%'
            app.update_page('#queue-bar', 'fadeOut', 'fast')
        dbg.stdout('Queue', 'Progress updated: "' + string + '" (' + percent + ')', 1, 4)

    def ui_add_card(self, program_id, status):
        # Get details for this card
        name = dynamicapps.get_attribute_for_app(program_id, 'name')
        img = dynamicapps.get_attribute_for_app(program_id, 'img')

        # Assemble strings
        buffer = self.card_template.replace('PROGRAM_ID', program_id).replace('PROGRAM_IMG', img).replace('PROGRAM_NAME', name)

        # What is the status on this card?
        if status == 'install':
            buffer = buffer.replace('DEFAULT_TEXT', '<span class="fa fa-download"></span> ' + string.status_install )
        elif status == 'remove':
            buffer = buffer.replace('DEFAULT_TEXT', '<span class="fa fa-trash"></span> ' + string.status_remove )

        # Add to page
        app.update_page('#queue-cards', 'append', buffer)
        dbg.stdout('Queue', 'Add new card for "' + program_id + '" with status "' + status + '".', 2, 4)

    def ui_update_card(self, program_id, string, colour=None):
        # Update the status label of a card.
        card_id   = '.card-' + program_id
        status_id = '.status-' + program_id

        app.update_page(status_id, 'html', string)
        if colour:
            if colour == 'error':
                app.update_page(card_id, 'addClass', 'failed')
                app.update_page(status_id, 'addClass', 'failed')
            elif colour == 'success':
                app.update_page(card_id, 'addClass', 'success')
                app.update_page(status_id, 'addClass', 'success')
        dbg.stdout('Queue', 'Card updated for "' + program_id + '"', 2, 4)

    def ui_remove_card(self, program_id):
        app.update_page('.card-' + program_id, 'slideUp')
        app.update_page('.card-' + program_id, 'attr', 'card-'+program_id, 'card-old-'+program_id)
        app.webkit.run_javascript('setTimeout(function(){ $("#card-old-' + program_id + '").remove(); }, 500);')

    def ui_update_count(self):
        app.update_page('#navigation-queue-count', 'html', str(self.queue_count))
        if self.queue_count == 0:
            app.update_page('#navigation-queue-count', 'addClass', 'empty')
        else:
            app.update_page('#navigation-queue-count', 'removeClass', 'empty')

    def is_enabled(self):
        enabled = pref.get('enable-queue', False)
        if enabled:
            return True
        else:
            return False

    def refresh_page_state(self):
        if self.is_enabled():
            app.update_page('#navigation-queue', 'show')
            app.update_page('#navigation-queue-disabled', 'hide')
        else:
            app.update_page('#navigation-queue', 'hide')
            app.update_page('#navigation-queue-disabled', 'show')


class WelcomeApp(object):

    def __init__(self):

        self.current_page = ""

        # establish our location
        self._location = os.path.dirname(
            os.path.abspath(inspect.getfile(inspect.currentframe())))

        # check for relative path
        if(os.path.exists(os.path.join(self._location, 'data/'))):
            print('Using relative path for data source.\
                   Non-production testing.')
            self._data_path = os.path.join(self._location, 'data/')
        elif(os.path.exists('/usr/share/antergos-welcome/')):
            print('Using /usr/share/antergos-welcome/ path.')
            self._data_path = '/usr/share/antergos-welcome/'
        else:
            print('Unable to source the antergos-welcome data directory.')
            sys.exit(1)

        self._build_app()

    def _build_app(self):
        # build window
        w = Gtk.Window()
        w.set_position(Gtk.WindowPosition.CENTER)
        w.set_wmclass('Budgie Remix Welcome', 'Budgie Remix Welcome')
        w.set_title('')
        w.set_size_request(992, 520)
        w.set_decorated(False)

        icon_dir = os.path.join(self._data_path, 'img', 'distro-icon.svg')
        w.set_icon_from_file(icon_dir)

        # build webkit container
        mv = AppView()

        # load our index file
        file = os.path.abspath(os.path.join(self._data_path, 'index.html'))
        uri = 'file://' + urllib.request.pathname2url(file)
        mv.load_uri(uri)

        # build scrolled window widget and add our appview container
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        sw.add(mv)

        # build a an autoexpanding box and add our scrolled window
        b = Gtk.VBox(homogeneous=False, spacing=0)
        b.pack_start(sw, expand=True, fill=True, padding=0)

        # add the box to the parent window and show
        w.add(b)
        w.connect('delete-event', self.close)
        w.show_all()

        self._window = w
        self.webkit = mv

    def run(self):
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        Gtk.main()

    def close(self, p1, p2):
        Gtk.main_quit(p1, p2)
        
    def update_page(self, element, function, parm1=None, parm2=None):
        """ Runs a JavaScript jQuery function on the page,
            ensuring correctly parsed quotes. """
        if parm1 and parm2:
            self.webkit.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "', '" + parm2.replace("'", '\\\'') + "')")
        if parm1:
            self.webkit.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "')")
        else:
            self.webkit.run_javascript('$("' + element + '").' + function + '()')

class Arguments(object):
    '''Check arguments passed the application.'''

    def __init__(self):
        self.verbose_enabled = False
        self.simulate_arch = None
        self.simulate_session = None
        self.simulate_codename = None
        self.simulate_no_connection = False
        self.simulate_force_connection = False
        self.jump_software_page = False
        self.simulate_software_changes = False
        self.locale = None
        self.jump_to = None

        for arg in sys.argv:
          if arg == '--help' or arg == '-h':
              print('\nWelcome App Parameters\n  Intended for debugging and testing purposes only!\n')
              print('\nUsage: budgie-remix-welcome [arguments]')
              #     | Command                      | Help Text                                     |
              print('  -d, --dev, --debug           Disables locales and is very verbose')
              print('                               intended for development purposes.')
              print('  --font-dpi=NUMBER            Adapt zoom setting based on DPI. Default 96.')
              print('  -h, --help                   Show this help text.')
              print('  --force-arch=ARCH            Simulate a specific architecture.')
              print('                                -- Options: i386, amd64, armhf, powerpc')
              print('  --force-codename=CODENAME    Simulate a specific release.')
              print('                                -- Examples: trusty, wily, xenial')
              print('  --force-net                  Simulate a working internet connection.')
              print('  --force-no-net               Simulate no internet connection.')
              print('  --force-session=TYPE         Simulate a specific architecture.')
              print('                                -- Options: guest, live, pi, vbox')
              print('  --jump-to=PAGE               Open a specific page, excluding *.html')
              print('  --locale=CODE                Locale to use. e.g. fr_FR.')
              print('  --simulate-changes           Simulate software package changes without')
              print('                               modifying the system.')
              print('  -b, -boutique,               Open Welcome only for the software selections.')
              print('  --software-only              ')
              print('  -v, --verbose                Show more details to stdout (for diagnosis).')
              print('')
              exit()

          if arg == '--verbose' or arg == '-v':
              dbg.stdout('Debug', 'Verbose mode enabled.', 0, 0)
              dbg.verbose_level = 1

          if arg.startswith('--force-arch'):
              try:
                  self.simulate_arch = arg.split('--force-arch=')[1]
                  if not self.simulate_arch == 'i386' and not self.simulate_arch == 'amd64' and not self.simulate_arch == 'armhf' and not self.simulate_arch == 'powerpc':
                      dbg.stdout('Debug', 'Unrecognised architecture: ' + self.simulate_arch, 0, 1)
                      exit()
                  else:
                      dbg.stdout('Debug', 'Simulating architecture: ' + self.simulate_arch, 0, 0)
              except:
                  dbg.stdout('Debug', 'Invalid arguments for "--force-arch"', 0, 1)
                  exit()

          if arg.startswith('--force-session'):
              try:
                  self.simulate_session = arg.split('--force-session=')[1]
                  if not self.simulate_session == 'guest' and not self.simulate_session == 'live' and not self.simulate_session == 'pi' and not self.simulate_session == 'vbox':
                      dbg.stdout('Debug', 'Unrecognised session type: ' + self.simulate_session, 0, 1)
                      exit()
                  else:
                      dbg.stdout('Debug', 'Simulating session: ' + self.simulate_session, 0, 0)
              except:
                  dbg.stdout('Debug', 'Invalid arguments for "--force-session"', 0, 1)
                  exit()

          if arg.startswith('--force-codename'):
              self.simulate_codename = arg.split('--force-codename=')[1]
              dbg.stdout('Debug', 'Simulating Ubuntu release: ' + self.simulate_codename, 0, 0)

          if arg == '--force-no-net':
              dbg.stdout('Debug', 'Simulating the application without an internet connection.', 0, 0)
              self.simulate_no_connection = True

          if arg == '--force-net':
              dbg.stdout('Debug', 'Forcing the application to think we\'re connected with an internet connection.', 0, 0)
              self.simulate_force_connection = True

          if arg == '--software-only' or arg == '--boutique' or arg == '-b':
              dbg.stdout('Welcome', 'Starting in Software Boutique mode.', 0, 0)
              self.jump_software_page = True

          if arg == '--simulate-changes':
              dbg.stdout('Debug', 'Any changes to software will be simulated without modifying the actual system.', 0, 0)
              self.simulate_software_changes = True

          if arg == '--dev' or arg == '--debug' or arg == '-d':
              dbg.stdout('Debug', 'Running in debugging mode.', 0, 0)
              dbg.verbose_level = 2
              self.locale = 'null'

          if arg.startswith('--locale='):
              self.locale = arg.split('--locale=')[1]
              dbg.stdout('Debug', 'Setting locale to: ' + self.locale, 0, 0)

          if arg.startswith('--jump-to='):
              self.jump_to = arg.split('--jump-to=')[1]
              dbg.stdout('Debug', 'Opening page: ' + self.jump_to + '.html', 0, 0)


    def override_arch(self):
        if not self.simulate_arch == None:
            systemstate.arch = self.simulate_arch

    def override_session(self):
        if not self.simulate_session == None:
            if self.simulate_session == 'vbox':
                systemstate.graphics_vendor = 'VirtualBox'
                systemstate.graphics_grep = 'VirtualBox'
            else:
                systemstate.session_type = self.simulate_session

    def override_codename(self):
        if not self.simulate_codename == None:
            systemstate.codename = self.simulate_codename

if __name__ == "__main__":

    # Process any parameters passed to the program.
    dbg = Debug()
    arg = Arguments()
    
    systemstate = SystemState()
    
    app = WelcomeApp()
    app.run()
