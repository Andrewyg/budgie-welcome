#! /usr/bin/python3
# -*- coding:utf-8 -*-
#
# Copyright 2012-2013 "Korora Project" <dev@kororaproject.org>
# Copyright 2013 "Manjaro Linux" <support@manjaro.org>
# Copyright 2014 Antergos
# Copyright 2016 Ubuntu Mate
# Copyright 2016 budgie-remix
#
# budgie-remix welcome is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# budgie-remix welcome is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with budgie-remix welcome. If not, see <http://www.gnu.org/licenses/>.
#

""" Welcome App for budgie-remix """

import gi

gi.require_version('WebKit2', '4.0')

import inspect
import os
# import json
import signal
import subprocess
import sys
import urllib.request
import urllib.error
import webbrowser
import socket
import platform

from gi.repository import WebKit2, Gtk
from threading import Thread

class AppView(WebKit2.WebView):

    def __init__(self):
        WebKit2.WebView.__init__(self)

        self.connect('load-changed', self._load_changed_cb)
        self.connect('notify::title', self._title_changed_cb)
        self.connect('context-menu', self._context_menu_cb)
        
        self.l_uri = None

    def _push_config(self):
        # TODO: push notification should be connected to angularjs and use a
        # broadcast event any suitable controllers will be able to listen and
        # respond accordingly, for now we just use jQuery to manually toggle

        self.run_javascript("$('#arch').html('%s')" % systemstate.arch)
        
        
            
        self.run_javascript("$('span[name=\"distro-name\"]').html('{}')".format(systemstate.distroname))

        if systemstate.session_type == 'live':
            app.update_page('.live-session-only', 'show') 
        else:
            app.update_page('.normal-session-only', 'show')

        
        if systemstate.is_online:
            self.run_javascript("$('.offline').hide()")
        else:
            self.run_javascript("$('.offline').show()")

        ### Getting Started Page ###
        if app.current_page == 'gettingstarted.html':
            # Display information tailored to graphics vendor (Getting Started / Drivers)
            self.run_javascript('var graphicsVendor = "' + systemstate.graphics_vendor + '";')
            self.run_javascript('var graphicsGrep = "' + systemstate.graphics_grep + '";')
            app.update_page('#boot-mode', 'html', systemstate.boot_mode)
        ### Index Page ###
        elif app.current_page == 'index.html':
            if systemstate.autostart:
                self.run_javascript("$('#autostart').html('&#xE837;')")
            else:
                self.run_javascript("$('#autostart').html('&#xE836;')")


    def _load_changed_cb(self, view, frame):
        uri = str(self.get_uri())
        app.current_page = uri.rsplit('/', 1)[1]
        self._push_config()

    def _title_changed_cb(self, view, frame):
        title = self.get_title()
        
        # An empty command get executed while toggling startup
        # option. Actual reason for this command execution needs
        # to be investigated.
        if title == '':
            return
        
        self._do_command(title)
        
    def _context_menu_cb(self, webview, menu, event, htr, user_data=None):
        # Disable context menu.
        return True

    def _do_command(self, uri):
      
        if uri == 'gnome-help':
            subprocess.Popen(['yelp'])
        elif uri == 'kde-help':
            subprocess.Popen(['khelpcenter'])
        # elif uri == 'install':
            # subprocess.Popen(['sudo','live-installer'])
        # elif uri == 'install-cli':
            # subprocess.Popen(['xdg-terminal','sudo setup'])
        elif uri == 'close':
            Gtk.main_quit()
        elif uri == 'toggle-startup':
            # toggle autostart
            systemstate.autostart_toggle()
            WebKit2.WebView.reload(self)
            
        elif uri == "checkInternetConnection":
            systemstate.check_internet_connection()
            self._push_config()
        elif uri.startswith("link?"):
            webbrowser.open_new_tab(uri[5:])
        elif uri == 'init-system-info':
            systemstate.get_system_info(self)
        else:
            print('Unknown command: %s' % uri)
       
class Debug(object):
    def __init__(self):
        self.verbose_level = 0

    def stdout(self, item, info, verbosity=0, colour=0):
        # Only colourise output if running in a real terminal.
        if sys.stdout.isatty():
            end = '\033[0m'
            if colour == 1:            # Failure (Red)
                start = '\033[91m'
            elif colour == 2:          # Success (Green)
                start = '\033[92m'
            elif colour == 3:          # Action (Yellow)
                start = '\033[93m'
            elif colour == 4:          # Debug (Blue)
                start = '\033[96m'
            else:                      # Normal/Misc (White)
                start = '\033[0m'

        # Ignore colours when redirected or piped.
        else:
            start = ''
            end   = ''

        # Output the message depending how detailed it is.
        if self.verbose_level >= verbosity:
            print(start + '[' + item + '] ' + info, end)            

class SystemState(object):
    def __init__(self):
        # Set default variables
        self.is_online = False
        self.updates_subscribed = False
        self.welcome_version = 'Unknown'

        # Full path to binary
        self._welcome_bin_path = os.path.abspath(inspect.getfile(inspect.currentframe()))

        # User's autostart directory and full path to autostart symlink.
        # Used for systemstate.autostart_toggle() function.
        self._autostart_dir = os.path.expanduser('~/.config/autostart/')
        self._autostart_path = os.path.expanduser(os.path.join(self._autostart_dir, 'budgie-welcome.desktop'))
        self.autostart = self.autostart_check()

        # Get current architecture of system.
        # Outputs 'i386', 'amd64', etc - Based on packages instead of kernel (eg. i686, x86_64).
        self.arch = str(subprocess.Popen(['dpkg','--print-architecture'], stdout=subprocess.PIPE).communicate()[0]).strip('\\nb\'')

        # Collect distribution info
        self.gatherDistroInfo()

        # Determine which type of session we are in.
        if arg.simulate_session:
            self.session_type = arg.simulate_session
        elif subprocess.call("df | grep -w / | grep -q '/cow'", shell=True) == 0:
            self.session_type = 'live'
        else:
            self.session_type = 'normal'

        # To inform the user if they are running in BIOS or UEFI mode.
        if os.path.exists("/sys/firmware/efi"):
            self.boot_mode = 'UEFI'
        else:
            self.boot_mode = 'BIOS'

        # Multithread to prevent holding up program execution.
        thread1 = Thread(target=self.check_internet_connection)
        thread2 = Thread(target=self.detect_graphics)
        thread1.start()
        thread2.start()


    def gatherDistroInfo(self):
        self.distroname = self.run_external_command(['lsb_release','-i','-s'])
        self.os_version = platform.dist()[1]    # → 14.04, 15.10, 16.04
        self.codename = platform.dist()[2]      # → trusty, wily, xenial

    def reload_cache(self):
        dbg.stdout('Apt', 'Reloading cache...', 0, 3)
        self.apt_cache.close()
        self.apt_cache = apt.Cache()
        dbg.stdout('Apt', 'Cache reloaded.', 0, 2)

    def autostart_check(self):
        # Ensure our autostart directories exist
        if not os.path.exists(self._autostart_dir):
            try:
                os.makedirs(self._autostart_dir)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while checking autostart directory: ' + str(err), 0, 1)
                pass

        # Set boolean if the autostart file exists.
        if os.path.exists(self._autostart_path):
            return True
        else:
            return False

    def autostart_toggle(self):
        if not os.path.exists(self._autostart_path):
            # create the autostart symlink
            try:
                os.symlink('/usr/share/applications/budgie-welcome.desktop', self._autostart_path)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while enabling autostart: ' + str(err), 0, 1)
                pass

        elif os.path.exists(self._autostart_path):
            # remove the autostart symlink
            try:
                os.unlink(self._autostart_path)
            except OSError as err:
                dbg.stdout('Welcome', 'Error while disabling autostart: ' + str(err), 0, 1)
                pass

        self.autostart = self.autostart_check()
        dbg.stdout('Welcome', 'Auto start toggled to: ' + str(self.autostart), 1, 2)

    def check_internet_connection(self):
        url = "http://archive.ubuntu.com/"
        dbg.stdout('Network Test', 'Establishing a connection test to "' + url + '"', 1, 3)

        if arg.simulate_no_connection:
            dbg.stdout('Network Test', 'Simulation flag: Forcing no connection presence. Retrying will reset this.', 0, 1)
            arg.simulate_no_connection = False
            self.is_online = False
            return

        if arg.simulate_force_connection:
            dbg.stdout('Network Test', 'Simulation flag: Forcing a connection presence.', 0, 2)
            dbg.stdout('Network Test', 'WARNING: Do not attempt to install/remove software offline as this may cause problems!', 0, 1)
            arg.simulate_connection = False
            self.is_online = True
            return

        try:
            response = urllib.request.urlopen(url, timeout=2).read().decode('utf-8')
        except socket.timeout:
            dbg.stdout('Network Test', 'Failed. Socket timed out to URL: ' + url, 0, 1)
            self.is_online = False
        except:
            dbg.stdout('Welcome', "Couldn't establish a connection: " + url, 0, 1)
            self.is_online = False
        else:
            dbg.stdout('Welcome', 'Successfully pinged: ' + url, 1, 2)
            self.is_online = True

    def detect_graphics(self):
        # TODO: Support dual graphic cards.
        dbg.stdout('Specs', 'Detecting graphics vendor... ', 1, 3)
        try:
            output = subprocess.Popen('lspci | grep VGA', stdout=subprocess.PIPE, shell='True').communicate()[0]
            output = output.decode(encoding='UTF-8')
        except:
            # When 'lspci' does not find a VGA controller (this is the case for the RPi 2)
            dbg.stdout('Specs', "Couldn't detect a VGA Controller on this system.", 0, 1)
            output = 'Unknown'

        # Scan for and set known brand name.
        if output.find('NVIDIA') != -1:
            self.graphics_vendor = 'NVIDIA'
        elif output.find('AMD') != -1:
            self.graphics_vendor = 'AMD'
        elif output.find('Intel') != -1:
            self.graphics_vendor = 'Intel'
        elif output.find('VirtualBox') != -1:
            self.graphics_vendor = 'VirtualBox'
        else:
            self.graphics_vendor = 'Unknown'

        self.graphics_grep = repr(output)
        self.graphics_grep = self.graphics_grep.split("controller: ",1)[1]
        self.graphics_grep = self.graphics_grep.split("\\n",1)[0]
        dbg.stdout('Specs', 'Detected: ' + str(self.graphics_grep), 1, 2)

    # Collect basic system information
    def run_external_command(self, command, with_shell=False):
        if with_shell:
            raw = str(subprocess.Popen(command, stdout=subprocess.PIPE, shell=True).communicate()[0])
        else:
            raw = str(subprocess.Popen(command, stdout=subprocess.PIPE).communicate()[0])
        output = raw.replace("b'","").replace('b"',"").replace("\\n'","").replace("\\n","")
        return output

    def get_system_info(self, webkit):
        dbg.stdout('Specs', 'Gathering system specifications...', 0, 3)

        # Append a failure symbol beforehand in event something goes horribly wrong.
        stat_error_msg = "Could not gather data."
        html_tag = '<a data-toggle=\'tooltip\' data-placement=\'top\' title=\'' + stat_error_msg + '\'><span class=\'fa fa-warning specs-error\'></span></a>'
        for element in ['distro', 'kernel', 'motherboard', 'boot-mode', 'cpu-model', 'cpu-speed', 'arch-use',
                        'arch-supported', 'memory', 'graphics', 'filesystem', 'capacity', 'allocated-space', 'free-space']:
            app.update_page('#spec'+element, 'html', html_tag)

        ## Distro
        try:
            dbg.stdout('Specs', 'Gathering Data: Distribution', 1, 0)
            distro_description = self.run_external_command(['lsb_release','-d','-s'])
            distro_codename = self.run_external_command(['lsb_release','-c','-s'])
            app.update_page('#spec-distro', 'html', distro_description)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Distribution', 0, 1)

        ## Kernel
        try:
            dbg.stdout('Specs', 'Gathering Data: Kernel', 1, 0)
            kernel = self.run_external_command(['uname','-r'])
            app.update_page('#spec-kernel', 'html', kernel)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Kernel', 0, 1)

        ## Motherboard
        try:
            dbg.stdout('Specs', 'Gathering Data: Motherboard', 1, 0)
            motherboard_name = self.run_external_command(['cat','/sys/devices/virtual/dmi/id/board_name'])
            app.update_page('#spec-motherboard', 'html', motherboard_name)
        except:
            dbg.stdout('Specs', 'Failed to gather data: Motherboard', 0, 1)

        ## CPU Details
        dbg.stdout('Specs', 'Gathering Data: CPU', 1, 0)
        try:
            cpu_model = self.run_external_command(['lscpu | grep "name"'], True).split(': ')[1]
            app.update_page('#spec-cpu-model', 'html', cpu_model)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Model', 0, 1)

        try:
            try:
                # Try obtaining the maximum speed first.
                cpu_speed = int(self.run_external_command(['lscpu | grep "max"'], True).split(': ')[1].strip(' ').split('.')[0])
            except:
                # Otherwise, fetch the CPU's MHz.
                cpu_speed = int(self.run_external_command(['lscpu | grep "CPU MHz"'], True).split(': ')[1].strip(' ').split('.')[0])

            app.update_page('#spec-cpu-speed', 'html', str(cpu_speed) + ' MHz')
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Speed', 0, 1)

        try:
            if self.arch == 'i386':
                cpu_arch_used = '32-bit'
            elif self.arch == 'amd64':
                cpu_arch_used = '64-bit'
            else:
                cpu_arch_used = self.arch
            app.update_page('#spec-arch-use', 'html', cpu_arch_used)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Architecture', 0, 1)

        try:
            cpu_arch_supported = self.run_external_command(['lscpu | grep "mode"'], True).split(': ')[1]
            app.update_page('#spec-arch-supported', 'html', cpu_arch_supported)
        except:
            dbg.stdout('Specs', 'Failed to gather data: CPU Supported Architectures', 0, 1)

        # Adding simple strings. Later this should be converted to translation
        # supported strings after referring welcome app
        gb_prefix = "GB"
        gib_prefix = "GiB"
        mb_prefix = "MB"
        mib_prefix = "MiB"

        ## Root partition (where Distribution is installed) and the rest of that disk.
        try:
            if self.session_type == 'live':
                app.update_page('.spec-hide-live-session', 'hide')
            else:
                dbg.stdout('Specs', 'Gathering Data: Storage', 1, 0)
                ## Gather entire disk data
                root_partition = self.run_external_command(['mount | grep "on / "'], True).split(' ')[0]
                if root_partition[:-2] == "/dev/sd":            # /dev/sdXY
                    root_dev = root_partition[:-1]
                if root_partition[:-2] == "/dev/hd":            # /dev/hdXY
                    root_dev = root_partition[:-1]
                if root_partition[:-3] == "/dev/mmcblk":        # /dev/mmcblkXpY
                    root_dev = root_partition[:-2]
                else:
                    root_dev = root_partition[:-1]              # Generic
                disk_dev_name = root_dev.split('/')[2]
                dbg.stdout('Specs', 'Distribution is installed on disk: ' + root_dev, 1, 4)
                rootfs = os.statvfs('/')
                root_size = rootfs.f_blocks * rootfs.f_frsize
                root_free = rootfs.f_bavail * rootfs.f_frsize
                root_used = root_size - root_free
                entire_disk = self.run_external_command(['lsblk -b | grep "' + disk_dev_name + '" | grep "disk"'], True)
                entire_disk = int(entire_disk.split()[3])

                ## Perform calculations across units
                capacity_GB =   round(entire_disk/1000/1000/1000,1)
                capacity_GiB =  round(entire_disk/1024/1024/1024,1)
                allocated_GB =  round(root_size/1000/1000/1000,1)
                allocated_GiB = round(root_size/1024/1024/1024,1)
                used_GB =       round(root_used/1000/1000/1000,1)
                used_GiB =      round(root_used/1024/1024/1024,1)
                free_GB =       round(root_free/1000/1000/1000,1)
                free_GiB =      round(root_free/1024/1024/1024,1)
                other_GB =      round((entire_disk-root_size)/1000/1000/1000,1)
                other_GiB =     round((entire_disk-root_size)/1024/1024/1024,1)

                # Show megabytes/mebibytes (in red) if gigabytes are too small.
                if capacity_GB <= 1:
                    capacity_GB = str(round(entire_disk/1000/1000,1)) + ' ' + mb_prefix
                    capacity_GiB = str(round(entire_disk/1024/1024,1)) + ' ' + mib_prefix
                else:
                    capacity_GB = str(capacity_GB) + ' ' + gb_prefix
                    capacity_GiB = str(capacity_GiB) + ' ' + gib_prefix

                if allocated_GB <= 1:
                    allocated_GB =  str(round(root_size/1000/1000,1)) + ' ' + mb_prefix
                    allocated_GiB = str(round(root_size/1024/1024,1)) + ' ' + mib_prefix
                else:
                    allocated_GB = str(allocated_GB) + ' ' + gb_prefix
                    allocated_GiB = str(allocated_GiB) + ' ' + gib_prefix

                if used_GB <= 1:
                    used_GB =  str(round(root_used/1000/1000,1)) + ' ' + mb_prefix
                    used_GiB = str(round(root_used/1024/1024,1)) + ' ' + mib_prefix
                else:
                    used_GB = str(used_GB) + ' ' + gb_prefix
                    used_GiB = str(used_GiB) + ' ' + gib_prefix

                if free_GB <= 1:
                    free_GB =  str(round(root_free/1000/1000,1)) + ' ' + mb_prefix
                    free_GiB = str(round(root_free/1024/1024,1)) + ' ' + mib_prefix
                    app.update_page('#spec-free-space', 'addClass', 'specs-error')
                else:
                    free_GB = str(free_GB) + ' ' + gb_prefix
                    free_GiB = str(free_GiB) + ' ' + gib_prefix

                if other_GB <= 1:
                    other_GB =  str(round((entire_disk-root_size)/1000/1000,1)) + ' ' + mb_prefix
                    other_GiB = str(round((entire_disk-root_size)/1024/1024,1)) + ' ' + mib_prefix
                else:
                    other_GB = str(other_GB) + ' ' + gb_prefix
                    other_GiB = str(other_GiB) + ' ' + gib_prefix

                ## Append data to HTML.
                app.update_page('#spec-filesystem', 'html', root_partition)
                app.update_page('#spec-capacity', 'html', capacity_GB + ' <span class=\'secondary-value\'>(' + capacity_GiB + ')</span>')
                app.update_page('#spec-allocated-space', 'html',  allocated_GB + ' <span class=\'secondary-value\'>(' + allocated_GiB + ')</span>')
                app.update_page('#spec-used-space', 'html', used_GB + ' <span class=\'secondary-value\'>(' + used_GiB + ')</span>')
                app.update_page('#spec-free-space', 'html', free_GB + ' <span class=\'secondary-value\'>(' + free_GiB + ')</span>')
                app.update_page('#spec-other-space', 'html', other_GB + ' <span class=\'secondary-value\'>(' + other_GiB + ')</span>')

                ## Calculate representation across physical disk
                disk_percent_UM_used = int(round(root_used / entire_disk * 100)) * 2
                disk_percent_UM_free = int(round(root_free / entire_disk * 100)) * 2
                disk_percent_other   = (200 - disk_percent_UM_used - disk_percent_UM_free)
                dbg.stdout('Specs', ' Disk: ' + root_dev, 1, 4)
                dbg.stdout('Specs', '  -- OS Used: ' + str(root_used) + ' bytes (' + str(disk_percent_UM_used/2) + '%)', 1, 4)
                dbg.stdout('Specs', '  -- OS Free: ' + str(root_free) + ' bytes (' + str(disk_percent_UM_free/2) + '%)', 1, 4)
                dbg.stdout('Specs', '  -- Other Partitions: ' + str(entire_disk - root_size) + ' bytes (' + str(disk_percent_other/2) + '%)', 1, 4)

                app.update_page('#disk-used', 'width', str(disk_percent_UM_used) + 'px')
                app.update_page('#disk-free', 'width', str(disk_percent_UM_free) + 'px')
                app.update_page('#disk-other', 'width', str(disk_percent_other) + 'px')

        except Exception as err:
            print(err)
            dbg.stdout('Specs', 'Failed to gather data: Storage', 0, 1)

        ## RAM
        try:
            dbg.stdout('Specs', 'Gathering Data: RAM (Memory)', 1, 0)
            ram_bytes = self.run_external_command(['free -b | grep "Mem:" '], True)
            ram_bytes = float(ram_bytes.split()[1])
            if round(ram_bytes / 1024 / 1024) < 1024:
                ram_xb = str(round(ram_bytes / 1000 / 1000, 1)) + ' ' + mb_prefix
                ram_xib = str(round(ram_bytes / 1024 / 1024, 1)) + ' ' + mib_prefix
            else:
                ram_xb =  str(round(ram_bytes / 1000 / 1000 / 1000, 1)) + ' ' + gb_prefix
                ram_xib = str(round(ram_bytes / 1024 / 1024 / 1024, 1)) + ' ' + gib_prefix
            ram_string = ram_xb + ' <span class=\'secondary-value\'>(' + ram_xib + ')</span>'
            app.update_page('#spec-memory', 'html', ram_string)
        except:
            dbg.stdout('Specs', 'Failed to gather data: RAM (Memory)', 0, 1)

        ## Graphics
        app.update_page('#spec-graphics', 'html', self.graphics_grep)

        # Check internet connectivity status.
        if self.is_online:
            app.update_page('#specs-has-net', 'show')
            app.update_page('#specs-has-no-net', 'hide')
        else:
            app.update_page('#specs-has-net', 'hide')
            app.update_page('#specs-has-no-net', 'show')


        # Display UEFI/BIOS boot mode.
        if systemstate.arch == 'i386' or systemstate.arch == 'amd64':
            app.update_page('#spec-boot-mode', 'html', self.boot_mode)

        # Hide root storage info if in a live session.
        if self.session_type == 'live':
            app.update_page('.spec-3', 'hide')

        # Data cached, ready to display.
        app.update_page('#specs-loading', 'fadeOut', 'fast')
        app.update_page('#specs-tabs', 'fadeIn', 'fast')
        app.update_page('#specs-basic', 'fadeIn', 'medium')
        app.update_page('#specs-busy-basic', 'fadeOut', 'fast')
        webkit.run_javascript('setCursorNormal()')
    
    def copy_to_clipboard(self, var):
        # Copies text to clipboard, passes 'var' containing what we'd like copying.
        if var == 'inxi':
            contents = self.inxi
        else:
            dbg.stdout('Clipboard', 'Unknown variable to copy: ' + var, 0, 1)
            return

        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
        clipboard.set_text(contents, -1)
        clipboard.store()
        dbg.stdout('Clipboard', 'Copied contents of: ' + var, 1, 2)





class WelcomeApp(object):

    def __init__(self):

        self.current_page = ""

        # establish our location
        self._location = os.path.dirname(
            os.path.abspath(inspect.getfile(inspect.currentframe())))

        # check for relative path
        if(os.path.exists(os.path.join(self._location, 'data/'))):
            print('Using relative path for data source.\
                   Non-production testing.')
            self._data_path = os.path.join(self._location, 'data/')
        elif(os.path.exists('/usr/share/budgie-remix-welcome/')):
            print('Using /usr/share/budgie-remix-welcome/ path.')
            self._data_path = '/usr/share/budgie-remix-welcome/'
        else:
            print('Unable to source the budgie-remix-welcome data directory.')
            sys.exit(1)

        self._build_app()

    def _build_app(self):
        # build window
        w = Gtk.Window()
        w.set_position(Gtk.WindowPosition.CENTER)
        w.set_wmclass('budgie-remix welcome', 'budgie-remix welcome')
        w.set_title('')
        w.set_size_request(992, 520)
        w.set_decorated(False)

        icon_dir = os.path.join(self._data_path, 'img', 'distro-icon.svg')
        w.set_icon_from_file(icon_dir)

        # build webkit container
        mv = AppView()

        # load our index file
        file = os.path.abspath(os.path.join(self._data_path, 'index.html'))
        uri = 'file://' + urllib.request.pathname2url(file)
        mv.load_uri(uri)

        # build scrolled window widget and add our appview container
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        sw.add(mv)

        # build a an autoexpanding box and add our scrolled window
        b = Gtk.VBox(homogeneous=False, spacing=0)
        b.pack_start(sw, expand=True, fill=True, padding=0)

        # add the box to the parent window and show
        w.add(b)
        w.connect('delete-event', self.close)
        w.show_all()

        self._window = w
        self.webkit = mv

    def run(self):
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        Gtk.main()

    def close(self, p1, p2):
        Gtk.main_quit(p1, p2)
        
    def update_page(self, element, function, parm1=None, parm2=None):
        """ Runs a JavaScript jQuery function on the page,
            ensuring correctly parsed quotes. """
        if parm1 and parm2:
            self.webkit.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "', '" + parm2.replace("'", '\\\'') + "')")
        if parm1:
            self.webkit.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "')")
        else:
            self.webkit.run_javascript('$("' + element + '").' + function + '()')

class Arguments(object):
    '''Check arguments passed the application.'''

    def __init__(self):
        self.verbose_enabled = False
        self.simulate_arch = None
        self.simulate_session = None
        self.simulate_codename = None
        self.simulate_no_connection = False
        self.simulate_force_connection = False
        self.jump_software_page = False
        self.simulate_software_changes = False
        self.locale = None
        self.jump_to = None

        for arg in sys.argv:
          if arg == '--help' or arg == '-h':
              print('\nWelcome App Parameters\n  Intended for debugging and testing purposes only!\n')
              print('\nUsage: budgie-remix-welcome [arguments]')
              #     | Command                      | Help Text                                     |
              print('  -d, --dev, --debug           Disables locales and is very verbose')
              print('                               intended for development purposes.')
              print('  --font-dpi=NUMBER            Adapt zoom setting based on DPI. Default 96.')
              print('  -h, --help                   Show this help text.')
              print('  --force-arch=ARCH            Simulate a specific architecture.')
              print('                                -- Options: i386, amd64, armhf, powerpc')
              print('  --force-codename=CODENAME    Simulate a specific release.')
              print('                                -- Examples: trusty, wily, xenial')
              print('  --force-net                  Simulate a working internet connection.')
              print('  --force-no-net               Simulate no internet connection.')
              print('  --force-session=TYPE         Simulate a specific architecture.')
              print('                                -- Options: guest, live, pi, vbox')
              print('  --jump-to=PAGE               Open a specific page, excluding *.html')
              print('  --locale=CODE                Locale to use. e.g. fr_FR.')
              print('  -v, --verbose                Show more details to stdout (for diagnosis).')
              print('')
              exit()

          if arg == '--verbose' or arg == '-v':
              dbg.stdout('Debug', 'Verbose mode enabled.', 0, 0)
              dbg.verbose_level = 1

          if arg.startswith('--force-arch'):
              try:
                  self.simulate_arch = arg.split('--force-arch=')[1]
                  if not self.simulate_arch == 'i386' and not self.simulate_arch == 'amd64' and not self.simulate_arch == 'armhf' and not self.simulate_arch == 'powerpc':
                      dbg.stdout('Debug', 'Unrecognised architecture: ' + self.simulate_arch, 0, 1)
                      exit()
                  else:
                      dbg.stdout('Debug', 'Simulating architecture: ' + self.simulate_arch, 0, 0)
              except:
                  dbg.stdout('Debug', 'Invalid arguments for "--force-arch"', 0, 1)
                  exit()

          if arg.startswith('--force-session'):
              try:
                  self.simulate_session = arg.split('--force-session=')[1]
                  if not self.simulate_session == 'normal' and not self.simulate_session == 'live':
                      dbg.stdout('Debug', 'Unrecognised session type: ' + self.simulate_session, 0, 1)
                      exit()
                  else:
                      dbg.stdout('Debug', 'Simulating session: ' + self.simulate_session, 0, 0)
              except:
                  dbg.stdout('Debug', 'Invalid arguments for "--force-session"', 0, 1)
                  exit()

          if arg.startswith('--force-codename'):
              self.simulate_codename = arg.split('--force-codename=')[1]
              dbg.stdout('Debug', 'Simulating Ubuntu release: ' + self.simulate_codename, 0, 0)

          if arg == '--force-no-net':
              dbg.stdout('Debug', 'Simulating the application without an internet connection.', 0, 0)
              self.simulate_no_connection = True

          if arg == '--force-net':
              dbg.stdout('Debug', 'Forcing the application to think we\'re connected with an internet connection.', 0, 0)
              self.simulate_force_connection = True

          if arg == '--dev' or arg == '--debug' or arg == '-d':
              dbg.stdout('Debug', 'Running in debugging mode.', 0, 0)
              dbg.verbose_level = 2
              self.locale = 'null'

          if arg.startswith('--locale='):
              self.locale = arg.split('--locale=')[1]
              dbg.stdout('Debug', 'Setting locale to: ' + self.locale, 0, 0)

          if arg.startswith('--jump-to='):
              self.jump_to = arg.split('--jump-to=')[1]
              dbg.stdout('Debug', 'Opening page: ' + self.jump_to + '.html', 0, 0)


if __name__ == "__main__":

    # Process any parameters passed to the program.
    dbg = Debug()
    arg = Arguments()
    
    systemstate = SystemState()
    
    app = WelcomeApp()
    app.run()
